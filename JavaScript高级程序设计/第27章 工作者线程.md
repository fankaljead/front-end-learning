

# 第27章 工作者线程

- 单线程就意味着不能像多线程语言那样把工作委托给独立的线程或进程完成。

- JavaScript 的单线程可以保证它与不同浏览器 API 兼容。

- 假如 JavaScript 可以多线程执行并发更改，那么像 DOM 这样的 API就会出现问题。

- 因此， POSIX 线程或 Java 的 Thread 类等传统并发结构都不适合 JavaScript。

- 而这也正是**工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型**。虽然本章要介绍的各种工作者线程有不同的形式和功能，但它们的共同的特点是都独立于JavaScript 的主执行环境。  

## 27.1 工作者线程简介  

**JavaScript 环境实际上是运行在托管操作系统中的虚拟环境。**

在浏览器中每打开一个页面，就会分配一个它自己的环境。

这样，**每个页面都有自己的内存、事件循环、 DOM，等等**。

每个页面就相当于一个沙盒，不会干扰其他页面。

对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。  



**使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。**

这个**子环境不能与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境并行执行代码。**  



### 27.1.1 工作者线程与线程  

作为介绍，通常需要将**工作者线程与执行线程进行比较**。在许多方面，这是一个恰当的比较，因为工作者线程和线程确实有很多共同之处。  

- **工作者线程是以实际线程实现的**。例如， Blink 浏览器引擎实现工作者线程的 WorkerThread 就对应着底层的线程
- **工作者线程并行执行**。虽然页面和工作者线程都是单线程 JavaScript 环境，每个环境中的指令则可以并行执行  
- **工作者线程可以共享某些内存**。工作者线程能够使用 `SharedArrayBuffer` 在多个环境间共享内容。虽然线程会使用锁实现并发控制，但 JavaScript 使用 Atomics 接口实现并发控制。工作者线程与线程有很多类似之处，但也有重要的区别
- **工作者线程不共享全部内存**。 在传统线程模型中，多线程有能力读写共享内存空间。
    - **除了 `SharedArrayBuffer` 外，从工作者线程进出的数据需要复制或转移**  

- **工作者线程不一定在同一个进程里**。通常，一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于。例如， Chrome 的 Blink 引擎对共享工作者线程和服务工作者线程使用独立的进程  
- **创建工作者线程的开销更大**。工作者线程有自己独立的事件循环、全局对象、事件处理程序和其他 JavaScript 环境必需的特性。创建这些结构的代价不容忽视  

无论形式还是功能，**工作者线程都不是用于替代线程的**。 HTML Web 工作者线程规范是这样说的：  

> **工作者线程相对比较重，不建议大量使用**。例如，对一张 400 万像素的图片，为每个像素都启动一个工作者线程是不合适的。通常，工作者线程应该是长期运行的，启动成本比较高，每个实例占用的内存也比较大。== 



### 27.1.2 工作者线程的类型  

- **专用工作者线程** 通常简称为工作者线程、 Web Worker 或 Worker，是一种实用的工具，**可以让脚本单独创建一个 JavaScript 线程，以执行委托的任务**。专用工作者线程，顾名思义，**只能被创建它的页面使用**
- **共享工作者线程** 共享工作者线程与专用工作者线程非常相似。**主要区别是共享工作者线程可以被多个不同的上下文使用**，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息
- **服务工作者线程**      服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的**主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者的角色。**  

> 注意 还有其他一些工作者线程规范，比如 ChromeWorker 或 Web Audio API，但它们并未得到广泛支持，或者定位于小众应用程序，

### **27.1.3 WorkerGlobalScope**  

在网页上， window 对象可以向运行在其中的脚本暴露各种全局变量。在工作者线程内部，没有 window 的概念。这里的全局对象是 `WorkerGlobalScope` 的实例，**通过 self 关键字暴露出来。**  

1. **`WorkerGlobalScope` 属性和方法**  

    self 上可用的属性是 window 对象上属性的严格子集。其中有些属性会返回特定于工作者线程的版本。

    - navigator：返回与工作者线程关联的 WorkerNavigator。
    - self：返回 WorkerGlobalScope 对象。
    - location：返回与工作者线程关联的 WorkerLocation。
    -  performance：返回（只包含特定属性和方法的） Performance 对象。
    -  console：返回与工作者线程关联的 Console 对象；对 API 没有限制。
    -  caches：返回与工作者线程关联的 CacheStorage 对象；对 API 没有限制。
    -  indexedDB：返回 IDBFactory 对象。
    -  isSecureContext：返回布尔值，表示工作者线程上下文是否安全。
    -  origin：返回 WorkerGlobalScope 的源  

    类似地， self 对象上暴露的一些方法也是 window 上方法的子集。这些 self 上的方法也与 window上对应的方法操作一样。  

    - atob()
    -  btoa()
    -  clearInterval()
    -  clearTimeout()
    -  createImageBitmap()
    -  fetch()
    -  setInterval()
    -  setTimeout()  

    **WorkerGlobalScope 还增加了新的全局方法 importScripts()，只在工作者线程内可用**  

2. **WorkerGlobalScope 的子类**  

    实际上并不是所有地方都实现了 WorkerGlobalScope。每种类型的工作者线程都使用了自己特定的全局对象，这继承自 WorkerGlobalScope。  

    - 专用工作者线程使用 DedicatedWorkerGlobalScope。
    -  共享工作者线程使用 SharedWorkerGlobalScope。
    -  服务工作者线程使用 ServiceWorkerGlobalScope。



## 27.2 专用工作者线程  

**专用工作者线程**是最简单的 Web 工作者线程，网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。

**这样的线程可以与父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务**（否则会导致页面响应迟钝）。  

> 注意 在使用工作者线程时，脚本在哪里执行、在哪里加载是非常重要的概念。

### 27.2.1 专用工作者线程的基本概念  

可以把专用工作者线程称为**后台脚本**（ background script）。

 **JavaScript 线程的各个方面，包括**

- **生命周期管理、**
- **代码路径和输入/输出，**

**都由初始化线程时提供的脚本来控制。该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始**  



1. **创建专用工作者线程**

    创建专用工作者线程最常见的方式是加载 JavaScript 文件。把文件路径提供给 Worker 构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程。传给构造函数的文件路径可以是多种形式。  

    ```javascript
    // emptyWorker.js
    // 空的 JS 线程工作者文件
    
    // main.js
    console.log(location.href); // "https://example.com/"
    const worker = new Worker(location.href + 'emptyWorker.js');
    console.log(worker); // Worker {}
    ```

    这个例子非常简单，但涉及几个基本概念。

    - emptyWorker.js 文件是从**绝对路径加载**的。根据应用程序的结构，使用绝对 URL 经常是多余的。
    -  这个文件是在后台加载的，**工作者线程的初始化完全独立于 main.js。**
    -  工作者线程本身存在于一个独立的 JavaScript 环境中， **因此 main.js 必须以 Worker 对象为代理实现与工作者线程通信**。在上面的例子中，该对象被赋值给了 worker 变量。
    -  虽然相应的工作者线程可能还不存在，但该 Worker 对象已在原始环境中可用了。

    前面的例子可修改为使用相对路径。不过，这要求 main.js 必须与 emptyWorker.js 在同一个路径下：  

    ```javascript
    const worker = new Worker('./emptyWorker.js');
    console.log(worker); // Worker {}
    ```

    ![image-20211225111611090](https://s2.loli.net/2021/12/25/jEiH4782KG3h1Zf.png)

2. **工作者线程安全限制  **

    **工作者线程的脚本文件只能从与父页面相同的源加载**。从其他源加载工作者线程的脚本文件会导致错误，如下所示：

    ```javascript
    // 尝试基于 https://example.com/worker.js 创建工作者线程
    const sameOriginWorker = new Worker('./worker.js');
    
    // 尝试基于 https://untrusted.com/worker.js 创建工作者线程
    const remoteOriginWorker = new Worker('https://untrusted.com/worker.js');
    
    // Error: Uncaught DOMException: Failed to construct 'Worker':
    // Script at https://untrusted.com/main.js cannot be accessed
    // from origin https://example.com
    ```

    **注意** 不能使用非同源脚本创建工作者线程，并不影响执行其他源的脚本。**在工作者线程内部，使用 importScripts()可以加载其他源的脚本**。 

    基于加载脚本创建的工作者线程不受文档的内容安全策略限制，因为工作者线程在与父文档不同的上下文中运行。不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容安全策略的限制。   

3. **使用 Worker 对象  **

    Worker()构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。  

    **注意 要管理好使用 Worker()创建的每个 Worker 对象。在终止工作者线程之前，它不会被垃圾回收，也不能通过编程方式恢复对之前 Worker 对象的引用。**  

    Worker 对象支持下列事件处理程序属性。

    - `onerror`：在工作者线程中发生 ErrorEvent 类型的错误事件时会调用指定给该属性的处理程序。
        - 该事件会在工作者线程中抛出错误时发生。
        -  该事件也可以通过 `worker.addEventListener('error', handler)` 的形式处理。
    - `onmessage`：在工作者线程中发生 MessageEvent 类型的消息事件时会调用指定给该属性的处理程序。
        - 该事件会在工作者线程向父上下文发送消息时发生。
        - 该事件也可以通过使用 worker.addEventListener('message', handler)处理。
    - `onmessageerror`：在工作者线程中发生 MessageEvent 类型的错误事件时会调用指定给该属性的处理程序。
        - 该事件会在工作者线程收到无法反序列化的消息时发生。
        - 该事件也可以通过使用 `worker.addEventListener('messageerror', handler)` 处理。  

    Worker 对象还支持下列方法。

    - `postMessage()`：用于通过异步消息事件向工作者线程发送信息。
    - `terminate()`：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。  

4. **DedicatedWorkerGlobalScope  **

    在专用工作者线程内部，全局作用域是 `DedicatedWorkerGlobalScope` 的实例。因为这继承自 `WorkerGlobalScope`，所以包含它的所有属性和方法。工作者线程可以通过 self 关键字访问该全局作用域。  

    ```javascript
    // globalScopeWorker.js
    console.log('inside worker:', self);
    
    // main.js
    const worker = new Worker('./globalScopeWorker.js');
    console.log('created worker:', worker);
    // created worker: Worker {}
    // inside worker: DedicatedWorkerGlobalScope {}
    ```

    ![image-20211225112138002](https://s2.loli.net/2021/12/25/thwL5TOiCy9NARP.png)

    如此例所示，顶级脚本和工作者线程中的 console 对象都将写入浏览器控制台，这对于调试非常有用。因为工作者线程具有不可忽略的启动延迟，所以即使 Worker 对象存在，工作者线程的日志也会在主线程的日志之后打印出来。  

    **注意** 这里两个独立的 JavaScript 线程都在向一个 console 对象发消息，该对象随后将消息序列化并在浏览器控制台打印出来。浏览器从两个不同的 JavaScript 线程收到消息，并**按照自己认为合适的顺序输出这些消息**。为此，在多线程应用程序中使用日志确定操作顺序时必须要当心。  

    `DedicatedWorkerGlobalScope` 在 `WorkerGlobalScope` 基础上增加了以下属性和方法。

    - `name`：可以提供给 Worker 构造函数的一个可选的字符串标识符。
    - `postMessage()`：与 `worker.postMessage()` 对应的方法，用于从工作者线程内部向父上下文发送消息。
    - `close()`：与 `worker.terminate()` 对应的方法，用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。
    - `importScripts()`：用于向工作者线程中导入任意数量的脚本  

### 27.2.2 专有工作者线程与隐式 MessagePorts

转悠工作者线程的 Worker 对象和 DedicatedWorkerGlobalScope 与 MEssagePorts 有一些相同接口处理程序和方法：

- `onmessage`
- `onmessageerror`
- `close()`
- `postMessage()`

这是因为专有工作者线程隐式使用了 MessagePorts 在两个上下文之间通信



父上下文中的 Worker 对象和 DedicateWorkerGlobalScope 实际上融合了 MessagePort,并在自己的接口中分别暴露了相应的处理程序和方法。

**也就是说，消息还是通过 MessagePort 发送，只是没有直接使用 MessagePort**



不同的地方是，例如 `start()` 和 `close()` 约定。

专有工作者线程会自动发送排队的消息，因此 `start()` 就没有必要了，

`close()` 在专有工作者线程的上下文中也没有意义，因为这样关闭 MessagePort 会导致工作者线程孤立。

所以在工作者线程内部调用 `close()` 或则外部调用 `terminate()` 不仅会关闭 MessagePort ，也会终止线程。

### 27.2.3 专有工作者线程的生命周期

1. **起点**： 调用 `Worker()` 构造函数是一个专有工作者线程生命的起点
2. 调用之后，会初始化对工作者线程脚本的请求，并把 Worker 对象返回给上下文
    - 虽然父上下文中可以立即使用这个 Worker 对象，但与之关联的工作者线程可能还没有创建，因为存在请求脚本的网络延迟和初始化延迟

- 一般来讲，**专有工作者线程可以非正式区分为三个状态**：
    1. **初始化 initializing**
    2. **活动 active**
    3. **终止 terminated**
- 这几个状态对其他上下文是不可见的
- 虽然 Worker 对象可能存在于父上下文中，但也无法通过他确定工作者线程当前是初始化、活动还是终止状态。
- 这就意味着，与活动的专用工作者线程关联的 Worker 对象与终止的专用工作者线程关联的 Worker 对象无法识别

**初始化时，虽然工作者线程脚本尚未执行，但可以先把发送给工作者线程的消息加入队列** 。

这些消息等待工作者线程的状态变为活动，在把消息加到它的消息队列：

```js
// initializingWorker.js
self.addEventListener("message", ({ data }) => console.log(data));

// main.js
const worker = new Worker("./initializingWorker.js");
console.log(worker);

// Worker 可能还处于初始化状态
// 但 postMessage() 数据可以正常处理
worker.postMessage("foo");
worker.postMessage("bar");
worker.postMessage("baz");
```

![image-20211225114403951](https://s2.loli.net/2021/12/25/p8WZlirOYxgGjtf.png)

创建之后，**专用工作者线程就会伴随页面的整个生命期而存在**，除非自我终止（ self.close()）或通过外部终止（ worker.terminate()）。**即使线程脚本已运行完成，线程的环境仍会存在**。只要工作者线程仍存在，与之关联的 Worker 对象就不会被当成垃圾收集掉。

**自我终止和外部终止最终都会执行相同的工作者线程终止例程**。

```js
// closeWorker.js
self.postMessage("foo");
self.close();
self.postMessage("bar");
setTimeout(() => self.postMessage("baz"), 0);

// main.js
const worker = new Worker("./closeWorker.js");
worker.onmessage = ({ data }) => console.log(data);
```

![image-20211225115048887](https://s2.loli.net/2021/12/25/GEgOHQCV2aivhYN.png)

然调用了 close()，但显然工作者线程的执行并没有立即终止**。 close()在这里会通知工作者线程取消事件循环中的所有任务，并阻止继续添加新任务**。这也是为什么"baz"没有打印出来的原因。**工作者线程不需要执行同步停止**，因此在父上下文的事件循环中处理的"bar"仍会打印出来。

外部终止的例子:

```js
// terminateWorker.js
self.onmessage = ({ data }) => console.log(data);


// main.js
const worker = new Worker("./terminateWorker.js");

// 给 1000 毫秒让工作者线程初始化
setTimeout(() => {
  worker.postMessage("foo");
  worker.terminate();
  worker.postMessage("bar");
  setTimeout(() => worker.postMessage("baz"), 0);
}, 1000);
```

![image-20211225121919565](https://s2.loli.net/2021/12/25/u4lB3GfPTkVOK92.png)

![image-20211225121953852](https://s2.loli.net/2021/12/25/R8MwYaVx2W9TGiZ.png)

这里 Google Chrome 和 Firefox 输出不同。这是由于 每个浏览器 对于 Worker 转换为 active 状态的不确定性而决定的。

这里，外部先给工作者线程发送了带"foo"的 postMessage，这条消息可以在外部终止之前处理。一旦调用了 terminate()，工作者线程的消息队列就会被清理并锁住，这也是只是打印"foo"的原因。

> close()和 terminate()是幂等操作，多次调用没有问题。这两个方法仅仅是将Worker 标记为 teardown，因此多次调用不会有不好的影响。

在整个生命周期中，一个专用工作者线程只会关联一个网页（ Web 工作者线程规范称其为一个文档）。除非明确终止，否则只要关联文档存在，专用工作者线程就会存在。如果浏览器离开网页（通过导航或关闭标签页或关闭窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会立即停止。

### 27.2.4 配置 Worker 选项

Worker()构造函数允许将可选的配置对象作为第二个参数。该配置对象支持下列属性。

- `name`:  可以在工作者线程中通过 self.name 读取到的字符串标识符。
- `type`:  表示加载脚本的运行方式，可以是"classic"或"module"。 "classic"将脚本作为常规脚本来执行， "module"将脚本作为模块来执行。
- `credentials`:  在 type 为"module"时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。值可以是"omit"、 "same-orign"或"include"。这些选项与 fetch()的凭证选项相同。在 type 为"classic"时，默认为"omit"。

> **注意** 有的现代浏览器还不完全支持模块工作者线程或可能需要修改标志才能支持

### 27.2.5 在 JavaScript 行内创建工作者线程

工作者线程需要基于脚本文件来创建，但这并不意味着该脚本必须是远程资源。**专用工作者线程也可以通过 Blob 对象 URL 在行内脚本创建**。这样可以更快速地初始化工作者线程，因为没有网络延迟。

```js
// 在 JavaScript 行内创建工作者线程
// 创建要执行的 JavaScript 代码字符串
const workerScript = `
self.onmessage = (event)=>console.log(event.data)
`;

// 基于脚本字符串生成 Blob 对象
const workerScriptBlob = new Blob([workerScript]);

// 基于 Blob 示例创建对象 URL
const workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob);

// 基于对象 URL 创建专用工作者线程
const worker = new Worker(workerScriptBlobUrl);

worker.postMessage("blob worker script");
```

如果把所有代码写在一块，可以浓缩为这样：

```js
const worker = new Worker(URL.createObjectURL(new Blob([`self.onmessage =
({data}) => console.log(data);`])));
worker.postMessage('blob worker script');
```

工作者线程也可以利用函数序列化来初始化行内脚本。这是因为函数的 toString()方法返回函数代码的字符串，而函数可以在父上下文中定义但在子上下文中执行。

```js
function fibonacci(n) {
  return n < 1
    ? 0
    : n < 2
    ? 1
    : arguments.callee(n - 1) + arguments.callee(n - 2);
}

const worker2Script = `
self.postMessage(
  (${fibonacci.toString()})(9)
)
`;

const worker2 = new Worker(URL.createObjectURL(new Blob([worker2Script])));

worker2.onmessage = function (event) {
  console.log(event.data);
};
```

![image-20211225144207500](https://s2.loli.net/2021/12/25/n8OlQ1atMwqBX9N.png)

**注意 像这样序列化函数有个前提，就是函数体内不能使用通过闭包获得的引用，也包括全局变量**，比如 window，因为这些引用在工作者线程中执行时会出错。

### 27.2.6 在工作者线程中动态执行脚本

工作者线程中的脚本并非铁板一块，而是可以使用 importScripts()方法通过编程方式加载和执行任意脚本。该方法可用于全局 Worker 对象。**这个方法会加载脚本并按照加载顺序同步执行**。

```js
// main.js
const worker = new Worker('./worker.js');

// importing scripts
// scriptA executes
// scriptB executes
// scripts imported


// scriptA.js
console.log("scriptA executes");

// scriptB.js
console.log("scriptB executes");


// worker.js
console.log('importing scripts');

importScripts('./scriptA.js');
importScripts('./scriptB.js');

console.log('scripts imported');
```

![image-20211225144925462](https://s2.loli.net/2021/12/25/GfCbIkuVQN4FSDL.png)

importScripts()方法可以接收任意数量的脚本作为参数。浏览器下载它们的顺序没有限制，但执行则会严格按照它们在参数列表的顺序进行。

因此，下面的代码与前面的效果一样：

```js
console.log('importing scripts');

importScripts('./scriptA.js', './scriptB.js');

console.log('scripts imported');
```

脚本加载受到常规 CORS 的限制，**但在工作者线程内部可以请求来自任何源的脚本**。这里的脚本导入策略类似于使用生成的`<script>`标签动态加载脚本。在这种情况下，所有导入的脚本也会共享作用域。

```js
// 在工作者线程中动态执行脚本
const worker = new Worker("./worker.js");

// scriptA.js
console.log(`scriptA executes in ${self.name} with ${globalToken}`);

// scriptB.js
console.log(`scriptB executes in ${self.name} with ${globalToken}`);

// worker.js
self.postMessage("foo");
self.close();
self.postMessage("bar");
setTimeout(() => self.postMessage("baz"), 0);
```

![image-20211225145451147](https://s2.loli.net/2021/12/25/KEgm2ANl7QDpkxJ.png)

### 27.2.7 委托任务到子工作者线程

有时候可能需要在工作者线程中再创建子工作者线程。在有多个 CPU 核心的时候，使用多个子工作者线程可以实现并行计算。使用多个子工作者线程前要考虑周全，确保并行计算的投入确实能够得到收益，毕竟同时运行多个子线程会有很大计算成本。

除了路径解析不同，创建子工作者线程与创建普通工作者线程是一样的。**子工作者线程的脚本路径根据父工作者线程而不是相对于网页来解析**。

```js
//main.js

const worker = new Worker('./js/worker.js');

// worker
// subworker
// js/worker.js
console.log('worker');
const worker = new Worker('./subworker.js');

//js/subworker.js
console.log('subworker');
```

![image-20211225150012111](https://s2.loli.net/2021/12/25/JObRUmEeAWM5N3s.png)

**注意 顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源加载。**

### 27.2.8 处理工作者线程错误

如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。如下例所示，其中的 try/catch 块不会捕获到错误：

```js
// 27.2.8 处理工作者线程错误
// main.js
try {
  const worker = new Worker("./worker.js");
  console.log("no error");
  worker.postMessage("hello my servant");
} catch (err) {
  console.log("caught error:", err);
}

// worker.js
onmessage = function (event) {
  console.log(event.data);
};

throw Error("foo");
```

![image-20211225151719509](https://s2.loli.net/2021/12/25/zqrSXo6OxieuCng.png)

### 27.2.9 与专有工作者线程通信

与工作者线程的通信都是通过异步消息完成的，但这些消息可以有多种形式。

1. **使用 `postMessage()`**

    最简单也最常用的形式是使用 postMessage()传递序列化的消息。下面来看一个计算阶乘的例子：

    ```js
    // factorialWorker.js
    function factorial(n) {
      let result = 1;
      while (n) {
        result *= n--;
      }
      return result;
    }
    
    self.onmessage = ({ data }) => {
      self.postMessage(`${data}!=${factorial(data)}`);
    };
    
    
    // main.js
    const factorialWorker = new Worker("./factorialWorker.js");
    
    factorialWorker.onmessage = ({ data }) => console.log(data);
    
    factorialWorker.postMessage(5);
    factorialWorker.postMessage(7);
    factorialWorker.postMessage(10);
    ```

    ![image-20211225152604200](https://s2.loli.net/2021/12/25/uPEhrW2Dix1BjdO.png)

    ![worker](https://s2.loli.net/2021/12/26/zKyrTIv3tbXEQok.png)

    对于传递简单的消息，使用 postMessage()在主线程和工作者线程之间传递消息，与在两个窗口间传递消息非常像。主要区别是没有 targetOrigin 的限制，该限制是针对` Window.prototype.postMessage `的，对 `WorkerGlobalScope.prototype.postMessage `或 `Worker.prototype.postMessage` 没有影响。这样约定的原因很简单：工作者线程脚本的源被限制为主页的源，因此没有必要再去过滤了。

2. **使用 MessageChannel**

    无论主线程还是工作者线程，通过 postMessage()进行通信涉及调用全局对象上的方法，并定义一个临时的传输协议。这个过程可以被 Channel Messaging API 取代，基于该 API **可以在两个上下文间明确建立通信渠道**。

    MessageChannel 实例有两个端口，分别代表两个通信端点。要让父页面和工作线程通过MessageChannel 通信，需要把一个端口传到工作者线程中，如下所示：

    ```js
    // worker.js
    function factorial(n) {
      let result = 1;
      while (n) {
        result *= n--;
      }
      return result;
    }
    
    // 在监听器中存储全局 messagePort
    let messagePort = null;
    
    // 在全局对象上添加消息处理程序
    self.onmessage = ({ ports }) => {
      // 只设置一次端口
      if (!messagePort) {
        // 初始化消息发送端口
        // 给变量赋值并重置监听器
        messagePort = ports[0];
        self.onmessage = null;
    
        // 在全局对象上设置消息处理程序
        messagePort.onmessage = ({ data }) => {
          // 收到消息后发送数据
          messagePort.postMessage(`${data}!=${factorial(data)}`);
        };
      }
    };
    
    // main.js
    const channel = new MessageChannel();
    const factorialWorker = new Worker("./factorialWorker.js");
    
    // 把 MessagePort 对象发送到工作者线程
    // 工作者线程负责处理初始化信道
    factorialWorker.postMessage(null, [channel.port1]);
    
    // 通过信道实际发送数据
    channel.port2.onmessage = ({ data }) => console.log(data);
    
    // 工作者线程通过信道响应
    channel.port2.postMessage(5);
    ```

    使用 MessageChannel 实例与父页面通信很大程度上是多余的。这是因为全局 postMessage()方法本质上与 channel.postMessage()执行的是同样的操作（不考虑 MessageChannel 接口的其他特性）。 **MessageChannel 真正有用的地方是让两个工作者线程之间直接通信**。这可以通过把端口传给另一个工作者线程实现。下面的例子把一个数组传给了一个工作者线程，这个线程又把它传另一个工作者线程，然后再传回主页：

    ```js
    // main.js
    const channel = new MessageChannel();
    
    const workerA = new Worker("./factorialWorker.js", { name: "workerA" });
    workerA.postMessage("workerA", [channel.port1]);
    workerA.onmessage = ({ data }) => console.log("workerA: ", data);
    workerA.postMessage(["pageA"]);
    
    const workerB = new Worker("./factorialWorker.js", { name: "workerB" });
    workerB.postMessage("workerB", [channel.port2]);
    workerB.onmessage = ({ data }) => console.log("workerB:", data);
    workerB.postMessage(["pageB"]);
    
    
    // worker.js
    let messagePort = null;
    let contextIdentifier = null;
    
    function addContextAndSend(data, destination) {
      data.push(contextIdentifier);
    
      destination.postMessage(data);
    }
    
    self.onmessage = ({ data, ports }) => {
      if (ports.length) {
        contextIdentifier = data;
    
        messagePort = ports[0];
    
        messagePort.onmessage = ({ data }) => {
          addContextAndSend(data, self);
        };
      } else {
        addContextAndSend(data, messagePort);
      }
    };
    ```

    ![image-20211226143744681](https://s2.loli.net/2021/12/26/mVaLbGQ8UW5qMih.png)

    执行顺序如下 (假设两个 workerA, workerB 都已经为 active 状态)：

    - workerA

        - 首先 Main 向 WorkerA 发送消息 （`workerA.postMessage("workerA", channel.port1)`）

            - 此时，workerA 中 `onmessage` 接收到 data 和 ports
            - 将 workerA 中的 contextIdentifier 设置为 “workerA”, messagePort 设置为 channel.port1
            - 并且给 messagePort（即 `channel.port1`） 设置 `onmessage` 事件

            - 然后 main 又向 worker 发送消息 (`workerA.postMessage([“pageA”]))`
                - 此时，没有 port 参数，进入 else 部分代码
                - 此时 addContextAndSend 的参数为 data=[“pageA”], destination=channel.port1
                - 进入函数，data.push(contextIdentifier) 即为 `[“pageA”].push(“workerA”)`
                - 然后` channel.port1.postMessage(data)` => `channel.port1.postMessage([“pageA”, “workerA”])`

            - 最后，channel.port2 发送消息给 channel.port1, 且消息为 `["pageB", "workerB"]` ，channel.port1.on,essage 里面
                - 此时 data 是 channel.port 传来的  `["pageB", "workerB"]`， addContextAndSend 函数中的 self 为当前的 wokerA 对象
                - 进入 addContextAndSend 中
                - `data.push(identifier) => [“pageB”, “workerB”, “pageA”]`
                - `workerA.postMessage(data) => workerA.postMessage([“pageB”, “workerB”, “pageA”])`

        - 最后，main 中执行 workerA 中的 onmessage 方法，打印 `workerA: ["pageB", "workerB", "workerA"]`

    - workerB 同理
        - 同时 Main 向 WorkerB 发送消息 （`workerA.postMessage("workerB", channel.port2)`）
            - 

    

    在这个例子中，数组的每一段旅程都会添加一个字符串，标识自己到过哪里。数组从父页面发送到工作者线程，工作者线程会加上自己的上下文标识符。然后，数组又从一个工作者线程发送到另一个工作者线程。第二个线程又加上自己的上下文标识符，随即将数组发回主页，主页把数组打印出来。这个例子中的两个工作者线程使用了同一个脚本，因此要注意数组可以双向传递。

3. **使用 BroadcastChannel**

    同源脚本能够通过 BroadcastChannel 相互之间发送和接收消息。这种通道类型的设置比较简单，不需要像 MessageChannel 那样转移乱糟糟的端口。这可以通过以下方式实现：

    ```js
    // main.js
    const channel = new BroadcastChannel("worker_channel");
    const worker = new Worker("./factorialWorker.js");
    
    channel.onmessage = ({ data }) => {
      console.log(`heard ${data} on page`);
    };
    
    setTimeout(() => {
      channel.postMessage("foo");
    }, 1000);
    
    // worker.js
    const channel = new BroadcastChannel("worker_channel");
    const worker = new Worker("./factorialWorker.js");
    
    channel.onmessage = ({ data }) => {
      console.log(`heard ${data} on page`);
    };
    
    setTimeout(() => {
      channel.postMessage("foo");
    }, 1000);
    ```

    ![image-20211225170001956](https://s2.loli.net/2021/12/25/JkLW4cGVZjSYOmP.png)

    这里，页面在通过 BroadcastChannel 发送消息之前会先等 1 秒钟。因为这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。在这种情况下，如果没有setTimeout()，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。

### 27.2.10 工作者线程数据传输

使用工作者线程时，经常需要为它们提供某种形式的数据负载。工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。在支持传统多线程模型的语言中，可以使用锁、互斥量，以及volatile 变量。

在 JavaScript 中，**有三种在上下文间转移信息的方式**： 

- **结构化克隆算法**（ structured clonealgorithm）、 

- **可转移对象**（ transferable objects）

- **共享数组缓冲区**（ shared array buffers）

1. **结构化克隆算法**

    **结构化克隆算法**可用于在两个独立上下文间共享数据。该算法由浏览器在后台实现，**不能直接调用**。

    **在通过 postMessage()传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本**。下列类型是结构化克隆算法支持的类型。

    - 除 Symbol 之外的所有原始类型
    - Boolean 对象
    - String 对象
    - BDate
    - RegExp
    - Blob
    - File
    - FileList
    - ArrayBuffer
    - ArrayBufferView
    - ImageData
    - Array
    - Object
    - Map
    - Set

    **关于结构化克隆算法，有以下几点需要注意。**

    - 复制之后，源上下文中对该对象的修改，不会传播到目标上下文中的对象。
    - 结构化克隆算法可以识别对象中包含的循环引用，不会无穷遍历对象。
    - 克隆 Error 对象、 Function 对象或 DOM 节点会抛出错误。
    - 结构化克隆算法并不总是创建完全一致的副本。
    - 对象属性描述符、获取方法和设置方法不会克隆，必要时会使用默认值。
    - 原型链不会克隆。
    -  RegExp.prototype.lastIndex 属性不会克隆

    **注意** **结构化克隆算法在对象比较复杂时会存在计算性消耗**。因此，实践中要尽可能避免过大、过多的复制。

2. **可转移对象**

    使用可转移对象（ transferable objects）可以把所有权从一个上下文转移到另一个上下文。**在不太可能在上下文间复制大量数据的情况下**，这个功能特别有用。只有如下几种对象是可转移对象：

    - **ArrayBuffer**
    - **MessagePort**
    - **ImageBitmap**
    - **OffscreenCanvas**

    postMessage()方法的第二个可选参数是数组，它指定应该将哪些对象转移到目标上下文。在遍历消息负载对象时，浏览器根据转移对象数组检查对象引用，并对转移对象进行转移而不复制它们。这意味着被转移的对象可以通过消息负载发送，消息负载本身会被复制，比如对象或数组。

    下面的例子演示了工作者线程对 ArrayBuffer 的常规结构化克隆。这里没有对象转移：

    ```js
    // main.js
    const worker = new Worker("./worker.js");
    
    // 创建 32 位缓冲区
    const arrayBuffer = new ArrayBuffer(32);
    
    console.log(`page's buffer size: ${arrayBuffer.byteLength}`);
    
    worker.postMessage(arrayBuffer);
    
    console.log(`page's buffer size: ${arrayBuffer.byteLength}`);
    
    // worker.js
    self.onmessage = (event) => {
      console.log(`worker's buffer size: ${event.data.byteLength}`);
    };
    ```

    ![image-20211225173827077](https://s2.loli.net/2021/12/25/x4qFywi3p8D6oTK.png)

    如果把 ArrayBuffer 指定为可转移对象，**那么对缓冲区内存的引用就会从父上下文中抹去**，**然后分配给工作者线程**。下面的例子演示了这个操作，结果分配给 ArrayBuffer 的内存从父上下文转移到了工作者线程：

    ```js
    // main.js
    const worker = new Worker("./worker.js");
    
    // 创建 32 位缓冲区
    const arrayBuffer = new ArrayBuffer(32);
    
    console.log(`page's buffer size: ${arrayBuffer.byteLength}`);
    
    worker.postMessage(arrayBuffer, [arrayBuffer]);
    
    console.log(`page's buffer size: ${arrayBuffer.byteLength}`);
    
    // worker.js
    self.onmessage = (event) => {
      console.log(`worker's buffer size: ${event.data.byteLength}`);
    };
    ```

    ![image-20211225174021042](https://s2.loli.net/2021/12/25/J3ZTGFlBrvO4QmU.png)

    在其他类型的对象中嵌套可转移对象也完全没有问题。包装对象会被复制，而嵌套的对象会被转移：

    ```js
    // main.js
    const worker = new Worker("./worker.js");
    
    // 创建 32 位缓冲区
    const arrayBuffer = new ArrayBuffer(32);
    
    console.log(`page's buffer size: ${arrayBuffer.byteLength}`);
    
    worker.postMessage({foo: {bar: arrayBuffer}}, [arrayBuffer]);
    
    console.log(`page's buffer size: ${arrayBuffer.byteLength}`);
    
    // worker.js
    self.onmessage = (event) => {
      console.log(`worker's buffer size: ${event.data.byteLength}`);
    };
    ```

    ![image-20211225174259917](https://s2.loli.net/2021/12/25/XVhKqRjwWGHgZoi.png)

3. **共享数据缓冲区**

    既不克隆，也不转移， SharedArrayBuffer 作为 ArrayBuffer 能够在不同浏览器上下文间共享。在把 SharedArrayBuffer 传给 postMessage()时，浏览器只会传递原始缓冲区的引用。结果是，两个不同的 JavaScript 上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区，就跟修改常规 ArrayBuffer 一样。来看下面的例子：

    ```js
    // main.js
    const worker = new Worker("./worker.js");
    
    // 创建 1 字节缓冲区
    const sharedArrayBuffer = new SharedArrayBuffer(1);
    
    // 创建 1 字节缓冲区视图
    const view = new Uint8Array(sharedArrayBuffer);
    
    // 父上下文赋值为 1
    view[0] = 1;
    
    worker.onmessage = () => {
      console.log(`buffer value after worker modification: ${view[0]}`);
    };
    
    // 发送对 sharedArrayBuffer 的引用
    worker.postMessage(sharedArrayBuffer);
    
    // worker.js
    self.onmessage = ({ data }) => {
      const view = new Uint8Array(data);
      console.log(`buffer value before worker modification: ${view[0]}`);
      view[0] += 1;
      self.postMessage(null);
    };
    ```

    当然，在两个并行线程中共享内存块有资源争用的风险。换句话说， SharedArrayBuffer 实例实际上会被当成易变（ volatile）内存。
    
    ```js
    // main.js
    // 创建包含 4 个线程的线程池
    const workers = [];
    for (let i = 0; i < 4; ++i) {
        workers.push(new Worker('./worker.js'));
    }
    // 在最后一个工作者线程完成后打印最终值
    let responseCount = 0;
    for (const worker of workers) {
        worker.onmessage = () => {
            if (++responseCount == workers.length) {
                console.log(`Final buffer value: ${view[0]}`);
            }
        };
    }
    // 初始化 SharedArrayBuffer
    const sharedArrayBuffer = new SharedArrayBuffer(4);
    const view = new Uint32Array(sharedArrayBuffer);
    view[0] = 1;
    // 把 SharedArrayBuffer 发给每个线程
    for (const worker of workers) {
        worker.postMessage(sharedArrayBuffer);
    }
    
    // （期待结果为 4000001。实际输出类似于：）
    // Final buffer value: 2145106
    
    // worker.js
    self.onmessage = ({data}) => {
        const view = new Uint32Array(data);
        // 执行 100 万次加操作
        for (let i = 0; i < 1E6; ++i) {
            view[0] += 1;
        }
        self.postMessage(null);
    };
    ```
    
    这里，每个工作者线程都顺序执行了 100 万次加操作，每次都读取共享数组的索引、执行一次加操作，然后再把值写回数组索引。在所有工作者线程读/写操作交织的过程中就会发生资源争用。
    
    为解决该问题，可以使用 Atomics 对象让一个工作者线程获得 SharedArrayBuffer 实例的锁，在执行完全部读/写/读操作后，再允许另一个工作者线程执行操作。把 Atomics.add()放到这个例子中就可以得到正确的最终值：
    
    ```js
    // main.js
    // 创建包含 4 个线程的线程池
    const workers = [];
    for (let i = 0; i < 4; ++i) {
        workers.push(new Worker('./worker.js'));
    }
    // 在最后一个工作者线程完成后打印最终值
    let responseCount = 0;
    for (const worker of workers) {
        worker.onmessage = () => {
            if (++responseCount == workers.length) {
                console.log(`Final buffer value: ${view[0]}`);
            }
        };
    }
    // 初始化 SharedArrayBuffer
    const sharedArrayBuffer = new SharedArrayBuffer(4);
    const view = new Uint32Array(sharedArrayBuffer);
    view[0] = 1;
    // 把 SharedArrayBuffer 发给每个线程
    for (const worker of workers) {
        worker.postMessage(sharedArrayBuffer);
    }
    
    //（期待结果为 4000001）
    // Final buffer value: 4000001
    
    // worker.js
    self.onmessage = ({data}) => {
        const view = new Uint32Array(data);
        // 执行 100 万次加操作
        for (let i = 0; i < 1E6; ++i) {
            Atomics.add(view, 0, 1);
        }
        self.postMessage(null);
    };
    ```

### 27.2.11 线程池

因为启用工作者线程代价很大，所以某些情况下可以考虑始终保持固定数量的线程活动，需要时就把任务分派给它们。工作者线程在执行计算时，会被标记为忙碌状态。直到它通知线程池自己空闲了，才准备好接收新任务。这些活动线程就称为“线程池”或“工作者线程池”。

线程池中线程的数量多少合适并没有权威的答案，不过可以参考 `navigator.hardware Concurrency`属性返回的系统可用的核心数量。因为不太可能知道每个核心的多线程能力，所以最好把这个数字作为线程池大小的上限。

**一种使用线程池的策略是每个线程都执行同样的任务，但具体执行什么任务由几个参数来控制**。通过使用特定于任务的线程池，可以分配固定数量的工作者线程，并根据需要为他们提供参数。工作者线程会接收这些参数，执行耗时的计算，并把结果返回给线程池。然后线程池可以再将其他工作分派给工作者线程去执行。接下来的例子将构建一个相对简单的线程池，但可以涵盖上述思路的所有基本要求。

首先是定义一个 TaskWorker 类，它可以扩展 Worker 类。 TaskWorker 类负责两件事：跟踪线程是否正忙于工作，并管理进出线程的信息与事件。另外，传入给这个工作者线程的任务会封装到一个期约中，然后正确地解决和拒绝。这个类的定义如下：

```js
// TaskWorker.js
class TaskWorker extends Worker {
  constructor(notifyAvailable, ...workerArgs) {
    super(...workerArgs);

    // 初始化为不可用状态
    this.available = false;
    this.resolve = null;
    this.reject = null;

    // 线程池会传递回调
    // 以便工作者线程发出它需要新任务的信号
    this.notifyAvailable = notifyAvailable;

    // 线程脚本会在完全初始化之后
    // 发送一条 "ready" 消息
    this.onmessage = () => this.setAvailable();
  }

  // 由线程池调用，以分派新任务
  dispatch({ resolve, reject, postMessageArgs }) {
    this.available = false;

    this.onmessage = ({ data }) => {
      resolve(data);
      this.setAvailable();
    };

    this.onerror = (e) => {
      reject(e);
      this.setAvailable();
    };

    this.postMessage(...postMessageArgs);
  }

  setAvailable() {
    this.available = true;
    this.resolve = null;
    this.reject = null;
    this.notifyAvailable();
  }
}

export default TaskWorker;
```

```js
// WorkerPool.js
import TaskWorker from "./TaskWorker.js";

class WorkerPool {
  constructor(poolSize, ...workerArgs) {
    this.taskQueue = [];
    this.workers = [];

    // 初始化线程池
    for (let i = 0; i < poolSize; ++i) {
      this.workers.push(
        new TaskWorker(() => this.dispatchIfAvailable(), ...workerArgs)
      );
    }
  }

  // 把任务推入队列
  enqueue(...postMessageArgs) {
    return new Promise((resolve, reject) => {
      this.taskQueue.push({ resolve, reject, postMessageArgs });
      this.dispatchIfAvailable();
    });
  }

  // 把任务发送到下一个空闲的线程 如果有的话
  dispatchIfAvailable() {
    if (!this.taskQueue.length) {
      return;
    }
    for (const worker of this.workers) {
      if (worker.available) {
        let a = this.taskQueue.shift();
        worker.dispatch(a);
        break;
      }
    }
  }

  // 终止所有工作者线程
  close() {
    for (const worker of this.workers) {
      worker.terminate();
    }
  }
}

export default WorkerPool;
```

```js
// MultiTaskTest.js
import WorkerPool from "./WorkerPool.js";
const totalFloats = 1e8,
  numTasks = 20,
  floatsPerTask = totalFloats / numTasks,
  numWorkers = 4;

// 创建线程池
const pool = new WorkerPool(numWorkers, "./worker.js");

// 填充浮点值数组
let arrayBuffer = new ArrayBuffer(4 * totalFloats),
  view = new Float32Array(arrayBuffer);
for (let i = 0; i < totalFloats; ++i) {
  view[i] = Math.random();
}

let partialSumPromises = [];
for (let i = 0; i < arr.length; i += floatsPerTask) {
  partialSumPromises.push(
    pool.enqueue({
      startIdx: i,
      endIdx: i + floatsPerTask,
      arrayBuffer: arrayBuffer,
    })
  );
}

Promise.all(partialSumPromises)
  .then((partialSums) => partialSums.reduce((x, y) => x + y))
  .then(console.log);
```

## 27.3 共享工作者线程

**共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。** 例如，同源的两个标签页可以访问同一个共享工作者线程。 SharedWorker 与 Worker 的消息接口稍有不同，包括外部和内部。

共享线程适合开发者希望通过在多个上下文间共享线程减少计算性消耗的情形。比如，可以用一个共享线程管理多个同源页面 WebSocket 消息的发送与接收。共享线程也可以用在同源上下文希望通过一个线程通信的情形。

### 27.3.1 共享工作者线程简介

从行为上讲，共享工作者线程可以看作是专用工作者线程的一个扩展。线程创建、线程选项、安全限制和 importScripts()的行为都是相同的。与专用工作者线程一样，共享工作者线程也在独立执行上下文中运行，也只能与其他上下文异步通信。

1. **创建共享工作者线程**

    与专用工作者线程一样，创建共享工作者线程非常常用的方式是通过加载 JavaScript 文件创建。此时，需要给 SharedWorker 构造函数传入文件路径，该构造函数在后台异步加载脚本并实例化共享工作者线程。

    ```js
    // emptySharedWorker.js
    // 空的 JavaScript 线程文件
    
    // main.js
    // 1. 创建共享工作者线程
    console.log(location.href);
    const sharedWorker = new SharedWorker(location.href + "emptySharedWorker.js");
    console.log(sharedWorker);
    ```

    ![image-20211226191501389](https://s2.loli.net/2021/12/26/NvPTtqghwIb7KZF.png)

2. **SharedWorkrer 表示与独占**

    共享工作者线程与专用工作者线程的一个重要区别在于，虽然 Worker()构造函数始终会创建新实例，而 SharedWorker()则只会在相同的标识不存在的情况下才创建新实例。如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。

    共享工作者线程标识源自解析后的脚本 URL、工作者线程名称和文档源。例如，下面的脚本将实例化一个共享工作者线程并添加两个连接:

    ```js
    // 实例化一个共享工作者线程
    // - 全部基于同源调用构造函数
    // - 所有脚本解析为相同的 URL
    // - 所有线程都有相同的名称
    new SharedWorker('./sharedWorker.js');
    new SharedWorker('./sharedWorker.js');
    new SharedWorker('./sharedWorker.js');
    ```

    类似地，因为下面三个脚本字符串都解析到相同的 URL，所以也只会创建一个共享工作者线程：

    ```js
    // 实例化一个共享工作者线程
    // - 全部基于同源调用构造函数
    // - 所有脚本解析为相同的 URL
    // - 所有线程都有相同的名称
    new SharedWorker('./sharedWorker.js');
    new SharedWorker('sharedWorker.js');
    new SharedWorker('https://www.example.com/sharedWorker.js');
    ```

    因为可选的工作者线程名称也是共享工作者线程标识的一部分，所以不同的线程名称会强制浏览器创建多个共享工作者线程。对下面的例子而言，一个名为'foo'，另一个名为'bar'，尽管它们同源且脚本 URL 相同：

    ```js
    // 实例化一个共享工作者线程
    // - 全部基于同源调用构造函数
    // - 所有脚本解析为相同的 URL
    // - 一个线程名称为'foo'，一个线程名称为'bar'
    new SharedWorker('./sharedWorker.js', {name: 'foo'});
    new SharedWorker('./sharedWorker.js', {name: 'foo'});
    new SharedWorker('./sharedWorker.js', {name: 'bar'});
    ```

    共享线程，顾名思义，可以在不同标签页、不同窗口、不同内嵌框架或同源的其他工作者线程之间共享。因此，下面的脚本如果在多个标签页运行，只会在第一次执行时创建一个共享工作者线程，后续执行会连接到该线程：

    ```js
    // 实例化一个共享工作者线程
    // - 全部基于同源调用构造函数
    // - 所有脚本解析为相同的 URL
    // - 所有线程都有相同的名称
    new SharedWorker('./sharedWorker.js');
    ```

    初始化共享线程的脚本只会限制 URL，因此下面的代码会创建两个共享工作者线程，尽管加载了相同的脚本：

    ```js
    // 实例化一个共享工作者线程
    // - 全部基于同源调用构造函数
    // - '?'导致了两个不同的 URL
    // - 所有线程都有相同的名称
    new SharedWorker('./sharedWorker.js');
    new SharedWorker('./sharedWorker.js?');
    ```

    如果该脚本在两个不同的标签页中运行，同样也只会创建两个共享工作者线程。每个构造函数都会检查匹配的共享工作者线程，然后连接到已存在的那个。

3. **使用 SharedWorker 对象**

    SharedWorker()构造函数返回的 SharedWorker 对象被用作与新创建的共享工作者线程通信的连接点。它可以用来通过 MessagePort 在共享工作者线程和父上下文间传递信息，也可以用来捕获共享线程中发出的错误事件。

    SharedWorker 对象支持以下属性:

    - onerror：在共享线程中发生 ErrorEvent 类型的错误事件时会调用指定给该属性的处理程序。
        -  此事件会在共享线程抛出错误时发生。
        -  此事件也可以通过使用 sharedWorker.addEventListener('error', handler)处理。
    -  port：专门用来跟共享线程通信的 MessagePort。

4. **SharedWorkerGlobalScope**

    在共享线程内部，全局作用域是 SharedWorkerGlobalScope 的实例。 SharedWorkerGlobalScope 继承自 WorkerGlobalScope，因此包括它所有的属性和方法。与专用工作者线程一样，共享工作者线程也可以通过 self 关键字访问该全局上下文。

    SharedWorkerGlobalScope 通过以下属性和方法扩展了 WorkerGlobalScope。

    - name：可选的字符串标识符，可以传给 SharedWorker 构造函数。
    - importScripts()：用于向工作者线程中导入任意数量的脚本。
    - close()：与 worker.terminate()对应，用于立即终止工作者线程。没有给工作者线程提供终止前清理的机会；脚本会突然停止。
    - onconnect： 与 共 享 线 程 建 立 新 连 接 时 ， 应 将 其 设 置 为 处 理 程 序 。 connect 事件包 括MessagePort 实例的 ports 数组，可用于把消息发送回父上下文。
    - 在通过 worker.port.onmessage 或 worker.port.start()与共享线程建立连接时都会触发 connect 事件。
    - connect 事件也可以通过使用 sharedWorker.addEventListener('connect', handler)处理

### 27.3.2 理解共享工作者线程的生命周期

共享工作者线程的生命周期具有与专用工作者线程相同的阶段的特性。不**同之处在于，专用工作者线程只跟一个页面绑定，而共享工作者线程只要还有一个上下文连接就会持续存在**。比如下面的脚本，每次调用它都会创建一个专用工作者线程：

```js
new Worker('./worker.js');
```

下表详细列出了当三个包含此脚本的标签页按顺序打开和关闭时会发生什么:

![image-20211226192056715](https://s2.loli.net/2021/12/26/utJoLbdFINh5jGV.png)

如上表所示，脚本执行次数、打开标签页数和运行的线程数是对等关系。下面再来看看这个简单的脚本，每次执行它都会创建或者连接到共享线程：

```js
new SharedWorker('./sharedWorker.js');
```

下表列出了当三个包含此脚本的标签页按顺序打开和关闭时会发生什么。

![image-20211226192127112](https://s2.loli.net/2021/12/26/zDKh6sbLCIq8BiF.png)

如上表所示，标签页 2 和标签页 3 再次调用 new SharedWorker()会连接到已有线程。随着连接的增加和移除，浏览器会记录连接总数。在连接数为 0 时，线程被终止。

关键在于，**没有办法以编程方式终止共享线程**。前面已经交代过， SharedWorker 对象上没有terminate()方法。在共享线程端口（稍后讨论）上调用 close()时，只要还有一个端口连接到该线程就不会真的终止线程。

SharedWorker 的“连接”与关联 MessagePort 或 MessageChannel 的状态无关。只要建立了连接，浏览器会负责管理该连接。建立的连接会在页面的生命周期内持续存在，只有当页面销毁且没有连接时，浏览器才会终止共享线程

### 27.3.3 连接到共享工作者线程

**每次调用 SharedWorker()构造函数，无论是否创建了工作者线程，都会在共享线程内部触发connect 事件**。下面的例子演示了这一点，在循环中调用 SharedWorker()构造函数：

```js
// sharedWorker.js
let i = 0;
self.onconnect = () => console.log(`connected ${++i} times`);

// main.js
for (let i = 0; i < 5; ++i) {
    new SharedWorker('./sharedWorker.js');
}
```

![image-20211226192531617](https://s2.loli.net/2021/12/26/hextwkUA4RlGEDO.png)

发生 connect 事件时， SharedWorker()构造函数会隐式创建 MessageChannel 实例，并把MessagePort 实例的所有权唯一地转移给该 SharedWorker 的实例。这个 MessagePort 实例会保存在 connect 事件对象的 ports 数组中。一个连接事件只能代表一个连接，因此可以假定 ports 数组的长度等于 1。

下面的代码演示了访问事件对象的 ports 数组。这里使用了 Set 来保证只跟踪唯一的对象实例：

```js
// sharedWorker.js
const connectedPorts = new Set();
self.onconnect = ({ports}) => {
    connectedPorts.add(ports[0]);
    console.log(`${connectedPorts.size} unique connected ports`);
};

//main.js
for (let i = 0; i < 5; ++i) {
    new SharedWorker('./sharedWorker.js');
}
```

![image-20211226192845927](https://s2.loli.net/2021/12/26/jPK5oFvZdDmLhSA.png)

关键在于，共享线程与父上下文的启动和关闭不是对称的。每个新 SharedWorker 连接都会触发一个事件，但没有事件对应断开 SharedWorker 实例的连接（如页面关闭）。

在前面的例子中，随着与相同共享线程连接和断开连接的页面越来越多， connectedPorts 集合中会受到死端口的污染，没有办法识别它们。一个解决方案是在 beforeunload 事件即将销毁页面时，明确发送卸载消息，让共享线程有机会清除死端口。

## 27.4 服务工作者线程

**服务工作者线程（ service worker）是一种类似浏览器中代理服务器的线程，可以拦截外出请求和缓存响应**。这可以让网页在没有网络连接的情况下正常使用，因为部分或全部页面可以从服务工作者线程缓存中提供服务。服务工作者线程也可以使用 Notifications API、 Push API、 Background Sync API 和Channel Messaging API。

**与共享工作者线程类似，来自一个域的多个页面共享一个服务工作者线程**。不过，为了使用 Push API等特性，服务工作者线程也可以在相关的标签页或浏览器关闭后继续等待到来的推送事件。

无论如何，对于大多数开发者而言，**服务工作者线程在两个主要任务上最有用**：

1. **充当网络请求的缓存层**
2. **和启用推送通知**。

在这个意义上，服务工作者线程就是用于把网页变成像原生应用程序一样的工具。

**注意** 服务工作者线程的生命周期取决于打开的同源标签页（称为“客户端”）数量、页面是否发生导航，以及服务脚本是否改变（以及其他一些因素）。如果对服务工作者线程的生命周期认识不够，
另外，在调试服务工作者线程时，要谨慎使用浏览器的强制刷新功能（ Ctrl+Shift+R）。强制刷新会强制浏览器忽略所有网络缓存，而服务工作者线程对大多数主流浏览器而言就是网络缓存。

### 27.4.1 服务工作者线程基础

作为一种工作者线程，服务工作者线程与专用工作者线程和共享工作者线程拥有很多**共性**。比如，**在独立上下文中运行，只能通过异步消息通信**。不过，服务工作者线程与专用工作者线程和共享工作者线程还是有很多本质区别的。

1. **ServiceWorkerContainer**

    **服务工作者线程与专用工作者线程或共享工作者线程的一个区别是没有全局构造函数**。服务工作者线程是通过 ServiceWorkerContainer 来管理的，它的实例保存在 navigator.serviceWorker 属性中。该对象是个顶级接口，通过它可以让浏览器创建、更新、销毁或者与服务工作者线程交互：

    ```js
    console.log(navigator.serviceWorker);
    ```

    ![image-20211226193817989](https://s2.loli.net/2021/12/26/ZQBlIzN7AToctkw.png)

2. **创建服务工作者线程**

    **与共享工作者线程类似，服务工作者线程同样是在还不存在时创建新实例，在存在时连接到已有实例。** ServiceWorkerContainer 没有通过全局构造函数创建，而是暴露了 register()方法，该方法以与 Worker()或 SharedWorker()构造函数相同的方式传递脚本 URL：

    ```js
    // emptyServiceWorker.js
    // 空服务脚本
    main.js
    // 注册成功，成功回调（解决）
    navigator.serviceWorker.register('./emptyServiceWorker.js')
        .then(console.log, console.error);
    
    
    // 使用不存在的文件注册，失败回调（拒绝）
    navigator.serviceWorker.register('./doesNotExist.js')
        .then(console.log, console.error);
    ```

    ![image-20211226194243148](https://s2.loli.net/2021/12/26/ZpIsJiVWy3Btcue.png)

    服务工作者线程对于何时注册是比较灵活的。在第一次调用 register()激活服务工作者线程后，后续在同一个页面使用相同 URL 对 register()的调用实际上什么也不会执行。此外，即使浏览器未全局支持服务工作者线程，服务工作者线程本身对页面也应该是不可见的。这是因为它的行为类似代理，就算有需要它处理的操作，也仅仅是发送常规的网络请求。

    考虑到上述情况，注册服务工作者线程的一种非常常见的模式是基于特性检测，并在页面的 load事件中操作。比如：

    ```js
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./serviceWorker.js');
        });
    }
    ```

    **如果没有 load 事件这个门槛，服务工作者线程的注册就会与页面资源的加载重叠，进而拖慢初始页面渲染的过程。除非该服务工作者线程负责管理缓存（这样的话就需要尽早注册，比如使用本章稍后会讨论的 clients.claim()），否则等待 load 事件是个明智的选择，这样同样可以发挥服务工作者线程的价值。**

3. **使用 ServiceWorkerContainer 对象**

    ServiceWorkerContainer 接口是浏览器对服务工作者线程生态的顶部封装。它为管理服务工作者线程状态和生命周期提供了便利。

    **ServiceWorkerContainer 始终可以在客户端上下文中访问**

    ServiceWorkerContainer 支持以下事件处理程序:

    - oncontrollerchange：在 ServiceWorkerContainer 触发 controllerchange 事件时会调用指定的事件处理程序。
        - 此事件在获得新激活的 ServiceWorkerRegistration 时触发。
        - 此事件也可以使用 navigator.serviceWorker.addEventListener('controllerchange',handler)处理。
    - onerror：在关联的服务工作者线程触发 ErrorEvent 错误事件时会调用指定的事件处理程序。
        - 此事件在关联的服务工作者线程内部抛出错误时触发。
        - 此事件也可以使用 navigator.serviceWorker.addEventListener('error', handler)处理。
    - onmessage：在服务工作者线程触发 MessageEvent 事件时会调用指定的事件处理程序。
        - 此事件在服务脚本向父上下文发送消息时触发。
        - 此事件也可以使用 navigator.serviceWorker.addEventListener('message', handler)处理。

4. **使用 ServiceWorkerRegisteration 对象**

    ServiceWorkerRegistration 对象表示注册成功的服务工作者线程。该对象可以在 register()返回的解决期约的处理程序中访问到。通过它的一些属性可以确定关联服务工作者线程的生命周期状态。

    调用 navigator.serviceWorker.register()之后返回的期约会将注册成功的 ServiceWorkerRegistration 对象（注册对象）发送给处理函数。在同一页面使用同一 URL 多次调用该方法会返回相同的注册对象:

    ```js
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./serviceWorker.js")
          .then((registrationA) => {
            console.log(registrationA);
            navigator.serviceWorker
              .register("./serviceWorker2.js")
              .then((registrationB) => {
                console.log(registrationB === registrationA);
              });
          });
      });
    }
    ```

    ![image-20211227145036288](https://s2.loli.net/2021/12/27/H6aRNmetFXEO1fg.png)

    ServiceWorkerRegistration 支持以下事件处理程序。

    - onupdatefound：在服务工作者线程触发 updatefound 事件时会调用指定的事件处理程序。
        - 此事件会在服务工作者线程开始安装新版本时触发，表现为 ServiceWorkerRegistration.installing 收到一个新的服务工作者线程。
        - 此事件也可以使用 serv serviceWorkerRegistration.addEventListener('updatefound',handler)处理。

    ServiceWorkerRegistration 支持以下通用属性。

    - scope：返回服务工作者线程作用域的完整 URL 路径。该值源自接收服务脚本的路径和在register()中提供的作用域。
    - navigationPreload：返回与注册对象关联的 NavigationPreloadManager 实例。
    - pushManager：返回与注册对象关联的 pushManager 实例。

    ServiceWorkerRegistration 还支持以下属性，可用于判断服务工作者线程处于生命周期的什么阶段:

    - installing：如果有则返回状态为 installing（安装）的服务工作者线程，否则为 null。
    - waiting：如果有则返回状态为 waiting（等待）的服务工作者线程，否则为 null。
    - active：如果有则返回状态 activating 或 active（活动）的服务工作者线程，否则为 null。

    注意，这些属性都是服务工作者线程状态的一次性快照。这在大多数情况下是没有问题的，因为活动状态的服务工作者线程在页面的生命周期内不会改变状态，除非强制这样做（比如调用 ServiceWorkerGlobalScope.skipWaiting()）。

    ServiceWorkerRegistration 支持下列方法:

    - getNotifications()：返回期约，解决为 Notification 对象的数组。
    - showNotifications()：显示通知，可以配置 title 和 options 参数。
    - update()：直接从服务器重新请求服务脚本，如果新脚本不同，则重新初始化。
    - unregister()：取消服务工作者线程的注册。该方法会在服务工作者线程执行完再取消注册。

5. **使用 ServiceWorker 对象**

    ServiceWorker 对象可以通过两种方式获得：通过 ServiceWorkerContainer 对象的 controller属性和通过 ServiceWorkerRegistration 的 active 属性。该对象继承 Worker 原型，因此包括其所有属性和方法，但没有 terminate()方法。

    ServiceWorker 支持以下事件处理程序:

    - onstatechange： ServiceWorker 发生 statechange 事件时会调用指定的事件处理程序。
        - 此事件会在 ServiceWorker.state 变化时发生。
        - 此事件也可以使用 serviceWorker.addEventListener('statechange', handler)处理。

    

6. **服务工作者线程的安全限制**

7. **ServiceWorkerGlobalScope**

8. **服务工作者线程作用于限制**

