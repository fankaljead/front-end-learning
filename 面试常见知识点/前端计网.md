# 2 计算机网络面试题

## 2.1 什么是网络协议，为什么要对网络协议分层

**网络协议** 是计算机在通信过程中要遵循的一些约定好的规则。

网络分层的原因：

- 易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。
- 有利于标准化的制定

## 2.2 计算机网络的各层协议及作用

计算机网络体系可以大致分为一下三种，七层模型、五层模型和TCP/IP四层模型，一般面试能流畅回答出五层模型就可以了，表示层和会话层被问到的不多。

![计算机网络协议分层](https://s2.loli.net/2022/02/15/cHpLR3dgbVnxDXr.png)

- 应用层

    应用层的任务是通过应用进程之间的交互来完成特定的网络作用，**常见的应用层协议有域名系统DNS，HTTP协议等。**

- 表示层

    表示层的主要作用是 **数据的表示、安全、压缩**。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

- 会话层

    **会话层的主要作用是建立通信链接，保持会话过程通信链接的畅通**，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。。

- 传输层

    传输层的主要作用是负责向两台主机进程之间的通信提供数据传输服务。**传输层的协议主要有传输控制协议TCP和用户数据协议UDP。**

- 网络层

    网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。**常见的协议有IP协议**。

- 数据链路层

    数据链路层的作用是在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。 **常见的协议有SDLC、HDLC、PPP等**。

- 物理层

    物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输介质和物理设备的差异。

## 2.3 URI 与 URL 的区别

- URI(Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。通常由三部分组成：

    - 访问资源的命名机制

    - 存放资源的主机名（地址）

    - 资源自身的名称

        > 举个例⼦：https://blog.csdn.net/qq_32595453/article/details/79516787 这是⼀个通过https协议访问的资源，放在了blog.csdn.net主机下，qq_32595453/article/details/79516787是对这个资源唯⼀的标识
        > 注意：URI只是⼀种概念，怎样组成都⽆所谓，只要能够唯⼀标识资源就⾏  

- URL(Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。

    它是⼀种具体的URI，是URI的⼀个⼦集，即URL可以⽤来标识⼀个资源，⽽且还指明了如何locate这个资源。URL是URI的⼀种具体实现⽅式。URL就是我们使⽤浏览器输⼊的⽹⻚地址，例如：http://baidu.com。URL主要有三部分组成：  

    - 第一部分是协议
    - 第二部分是存放该资源的主机IP地址
    - 第三部分是该资源的具体地址

URI=URL+URN

有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人

- URI和URL都定义了资源是什么，但是URL还定义了如何访问资源
- URL是URI的⼀个⼦集，URL是URI的⼀种具体实现⽅式。URI是⼀种⾼层级的抽象概念，可以使绝对也可
    以是相对，⽽URL则必须提供⾜够的信息来定位，是绝对的  

## 2.4 DNS 工作流程

DNS的定义：DNS的全称是domain name  system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。

### 2.4.1 DNS 是集群式的工作方式还是 单点式的，为什么？

 答案是**集群式**的，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。

### 2.4.2 DNS 工作流程

> **主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询。**
>
> 递归查询主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。迭代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器向顶级域名发送查询请求报文。
>
> 简单来说，递归查询就是，小明问了小红一个问题，小红不知道，但小红是个热心肠，小红就去问小王了，小王把答案告诉小红后，小红又去把答案告诉了小明。迭代查询就是，小明问了小红一个问题，小红也不知道，然后小红让小明去问小王，小明又去问小王了，小王把答案告诉了小明。

1. 在浏览器中输入www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
2. 如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析。
3. 如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。
4. 如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器。
5. 本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器。
6. 本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器www.baidu.com所对应的IP地址。
7. 本地域名服务器告诉主机www.baidu.com所对应的IP地址。

## 2.5 ARP 协议

ARP协议属于网络层的协议，**主要作用是实现从IP地址转换为MAC地址**。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。

- IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
- MAC地址：MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。

数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。从下图可以看到TCP报文在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址

![在这里插入图片描述](https://s2.loli.net/2022/02/15/4Fx9OJfpG28l5UH.png)

**网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信**，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。

![https://image-static.segmentfault.com/490/933/490933877-2ed6acc40478ed77_fix732](https://s2.loli.net/2022/02/18/YLdvVfeohIkuXQm.png)

ARP的工作流程(面试时问ARP协议主要说这个就可以了)：

1. 在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。
2. 如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。
3. 主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。
4. 主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。
5. 如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。
6. 如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。

## 2.6 有了 IP 地址，为什么还要用 MAC 地址

简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但 **计算机的IP地址可由用户自行更改，管理起来相对困难**，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。

那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。

那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。

**IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。**

## 2.7 PING 的过程

ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。

- **机器A ping 机器B**

    - 同一网段

        1. ping 通知系统建立一个固定格式的 ICMP 请求数据包
        2. ICMP 协议打包这个数据包和机器B的IP地址转交给 IP 协议层
        3. IP 层协议将以机器B 的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包
        4. 获取机器B的MAC地址
            - IP 层协议通过机器B的IP地址和自己的子网掩码，发现它和自己同于同一网络，就直接在本网络查找这台机器的 MAC
                - 若两台机器之前有过通信，在机器A的ARP缓存表应该有机器B的IP和MAC映射关系
                - 若没有，则A发送ARP请求广播，得到机器B的MAC地址，一并交给数据链路层
            - 数据链路层构建一个数据帧，目的地址是 IP 层传来的MAC地址，源地址是本机A的MAC地址，在附加一个控制信息，依据以太网的介质访问规则，将他们传送出去
            - 机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比
                - 符合，接收。介绍后检查改数据帧，将IP数据包从帧中提取出来，交给本机的IP协议层。IP层检查完毕后，将有用的信息提取交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到B类似（这时候主机B已经知道主机A的MAC地址，无需再发送ARP请求）
                - 不符合，则丢弃

    - 不同网段

        1. ping 通知系统简历一个固定格式的ICMP请求数据包

            1. ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层

            2. IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包

            3. 获取主机B的MAC地址

                1. P协议通过计算发现主机B与自己不在同一网段内，就直接交给路由处理，就是将路由的MAC取过来，至于怎么得到路由的MAC地址，和之前一样，先在ARP缓存表中寻找，找不到可以利用广播。路由得到这个数据帧之后，再跟主机B联系，若找不到，就向主机A返回一个超时信息。

                     

- **对ping后返回信息的分析**

    1. Request timed out

        - 对方已关机，或者网络上没有这个地址

        - 对方与自己不在同一网段内，通过路由也无法到达

        - 对方存在，不过设置了ICMP数据包过滤（比如防火墙设置）

        - 错误设置IP地址

    2. Destination host Unreachable

        - 自己未设定默认路由，对方跟自己不在同已网段
        - 网线有问题

        > **Request timed out 与 Destination host Unreachable 的区别**
        > 所经过的路由器的路由表具有到达目标的路由，而目标因为原因不可到达，这时出现前者。如果路由表中连到达目标的路由都没有，就会出现后者。

    3. Bad ip address

        - 没有连接到DNS服务器，无法解析IP，也可能是IP不存在

    4. Source quench received

        - 对方或中途服务器繁忙而无法应答

    5. Unknown host

        - 远程主机的名字不能被域名服务器转换成IP地址，故障原因可能是DNS服务器有故障，或者名字不正确，或者网络管理员的系统与远程主机之间的通信线路故障。

    6. No answer

        - 无响应。说明本地系统有一条通向中心主机的路由，但却接收不到它发给该中心主机的人呢和信息。故障原因可能是：中心主机没有工作；本地或中心主机网络配置不正确；本地或中心的路由器没有工作；通信线路有故障；中心主机存在路由选择问题。

    7. Ping 127.0.0.1

        - 如果ping不通，则表明本地址TCP/IP协议不能正常工作

    8. no rout  to host

        - 网卡工作不正常

    9. transmit failed。error code

        - 10043网卡驱动不正常

    10. unknown host name

        - DNS配置不正确

## 2.8 路由器和交换机的区别

|        | 所属网络模型的层级 | 功能                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| 路由器 | 网络层             | 识别IP地址并根据IP地址转发数据包，维护数据表并基于数据表进行最佳路径选择 |
| 交换机 | 数据链库层         | 识别MAC地址并根据MAC地址转发数据帧                           |

## 2.9 TCP 与 UDP 

### 2.9.1 TCP 与 UDP 的区别

- **用户数据报协议 UDP（User Datagram Protocol）**

    是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

- **传输控制协议 TCP（Transmission Control Protocol）**

    是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

|      | 是否面向连接 | 可靠性 | 传输形式   | 传输效率 | 消耗资源 | 应用场景      | 首部字节 |
| ---- | ------------ | ------ | ---------- | -------- | -------- | ------------- | -------- |
| TCP  | 面向连接     | 可靠   | 字节流     | 慢       | 多       | 文件/邮件传输 | 20~60    |
| UDP  | 无连接       | 不可靠 | 数据报文段 | 快       | 少       | 视频/语音传输 | 8        |

- TCP是面向 **链接** 的，而UDP是面向 **无连接** 的。
- TCP仅支持 **单播传输**，UDP 提供了单播，多播，广播的功能。
- TCP的三次握手保证了连接的 **可靠性**; UDP是无连接的、**不可靠** 的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。
- UDP的 **头部开销** 比TCP的更小，数据 **传输速率更高**，**实时性更好**。



- TCP首部(图片来源于网络)：

​		前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。



![https://image-static.segmentfault.com/300/564/3005641202-967325d56c07571e_fix732](https://s2.loli.net/2022/02/18/TuHGszBJLZtdW25.jpg)

- UDP首部

    UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。

    

    ![https://image-static.segmentfault.com/216/722/2167223408-05ad93cb568c2c99_fix732](https://s2.loli.net/2022/02/18/GRgwOXEmzAUTtyB.jpg)

### 2.9.2 TCP 短连接与长连接的区别

**短连接：**Client 向 Server 发送消息，Server 回应 Client，**然后一次读写就完成了**，这时候双方任何一个都可以发起 close  操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。



**短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段**。



**长连接：**Client 与 Server 完成一次读写之后，它们之间的 **连接并不会主动关闭**，后续的读写操作会继续使用这个连接。



在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server  压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server  端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。



长连接和短连接的产生在于 Client 和 Server 采取的 **关闭策略**，具体的应用场景采用具体的策略。

### 2.9.3 TCP 粘包、拆包及解决办法

- **为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？**

    - UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此**在应用层能很好的将不同的数据报文区分开**，从而避免粘包和拆包的问题。

    - 而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 **TCP  并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流**；另外从 TCP 的帧结构也可以看出，在 TCP  的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。

- **什么是粘包、拆包？**

    假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：

    - 第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。

        ![接收端正常收到两个数据包](https://s2.loli.net/2022/03/21/EjCw6FZkaAWzLDs.png)

    - 第二种情况，**接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包**。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

        ![粘包](https://s2.loli.net/2022/03/21/SvEkXU6xrytNe7C.png)

    - 第三种情况，这种情况有两种表现形式，如下图。**接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包**。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。

        ![粘包与拆包](https://s2.loli.net/2022/03/21/AHKMCv2QZfig4pq.png)

- **为什么会发生 TCP 粘包、拆包？**

    - 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
    - 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
    - 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
    - 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

- **粘包、拆包解决办法**

    由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以 **在底层是无法保证数据包不被拆分和重组的**，这个问题 **只能通过上层的应用协议栈设计来解决**，根据业界的主流协议的解决方案，归纳如下：

    - **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
    - **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
    - **将消息分为消息头和消息体：**消息头中包含表示消息总长度（或者消息体长度）的字段。
    - 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。

- 

## 2.10 TCP协议如何保证可靠传输

主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。

- **校验和**：**在发送端和接收端分别计算数据的校验和**，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。

- **序列号**：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃

​	![TCP保证可靠传输-序列号](https://s2.loli.net/2022/02/15/VoSkI4DzvR98UHX.png)

- **超时重传**：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。

    这里发送方没有收到ACK可以分两种情况，如果是发送方发送的数据包丢失了，接收方收到发送方重新发送的数据包后会马上给发送方发送ACK；

    如果是接收方之前接收到了发送方发送的数据包，而返回给发送方的ACK丢失了，这种情况，发送方重传后，接收方会直接丢弃发送方冲重传的数据包，然后再次发送ACK响应报文。

    如果数据被重发之后还是没有收到接收方的确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。

- **流量控制**：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。

- **拥塞控制**：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复，如下图(图片来源于网络)。

​		![在这里插入图片描述](https://s2.loli.net/2022/02/15/54xAqDQmjLPdt7u.png)

## 2.11 TCP的三次握手及四次挥手

TCP头部的一些常用字段。

- 顺序号：seq(Sequence number)，占32位，用来标识从发送端到接收端发送的字节流。
- 确认号：ack(Acknowledge number)，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- 标志位：
    - SYN(synchronous)：发起一个新连接。
    - FIN(finish)：释放一个连接。
    - ACK(acknowledgement)：确认序号有效。

### 2.11.1 三次握手

**三次握手的本质就是确定发送端和接收端具备收发信息的能力**，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住每次握手时 **接收端和发送端的状态**。这个比较容易忽略

先看一张很经典的图（图片来源于网络），发送端有CLOSED、SYN-SENT、ESTABLISHED三种状态，接收端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态。

![在这里插入图片描述](https://s2.loli.net/2022/02/15/1bJStNiqVrjLhPa.png)

假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE。

- 第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN
- 第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）
- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED

需要注意的一点是，第一次握手，客户端向服务端发起建立连接报文，会占一个序列号。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，客户端向服务端发送的第一个数据的序列号为x+1

### 2.11.2 四次挥手

和三次握手一样，先看一张非常经典的图（图片来源于网络），客户端在四次挥手过程中有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED等五个状态，服务端有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED等四种状态。最好记住每次挥手时服务端和客户端的状态。

假设客户端首先发起的断开连接请求：



![四次挥手](https://s2.loli.net/2022/02/18/7TFR123H8aumMSw.jpg)

1. 客户端Client进程发出连接释放报文，并且停止发送数据。其中FIN=1，顺序号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端Client进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2. 服务器Server收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的顺序号seq=v，此时，服务器Server就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端Client向服务器的方向就释放了，这时候处于半关闭状态，即客户端Client已经没有数据要发送了，**但是服务器Server若发送数据，客户端Client依然要接受**。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3. 客户端Client收到服务器Server的确认信息后，此时，客户端Client就进入FIN-WAIT-2（终止等待2）状态，等待服务器Server发送连接释放报文（在这之前还需要接受服务器Server发送的最后的数据）。

4. 服务器Server将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器Server很可能又发送了一些数据，假定此时的顺序号为seq=w，此时，服务器Server就进入了LAST-ACK（最后确认）状态，等待客户端Client的确认。

5. 客户端Client收到服务器Server的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的顺序号是seq=u+1，此时，客户端Client就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端Client撤销相应的TCB（保护程序）后，才进入CLOSED状态。

6. 服务器Server只要收到了客户端Client发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器Server结束TCP连接的时间要比客户端Client早一些。



- 第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位FIN=1，序列号seq=u。此时客户端只能接收数据，不能向服务端发送数据。
- 第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK=1，序列号seq=v，确认号ack=u+1。此时客户端到服务端的连接已经释放掉，客户端不能像服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。
- 第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。
- 第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。

### 2.11.3 为什么TCP连接的时候是3次？两次是否可以？

不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：

1. 假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。
2. 如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。

### 2.11.4 为什么TCP连接的时候是3次，关闭的时候却是4次？

因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，**服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文**，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。

### 2.11.5 TIME_WAIT和CLOSE_WAIT的区别在哪?

默认客户端首先发起断开连接请求

- 从上图可以看出，CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。
- TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。

### 2.11.6 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

MSL的意思是报文的最长寿命，可以从两方面考虑：

1. 客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。
2. 考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭

### 2.11.7 如果已经建立了连接，但是客户端突然出现故障了怎么办？

如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。**具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达**，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。

保活机制原理：设置TCP保活机制的保活时间 keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。

## 2.12 HTTP 与 HTTPS 的区别

- http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
- https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

|              | HTTP               | HTTPS                                   |
| ------------ | ------------------ | --------------------------------------- |
| 端口         | 80                 | 443                                     |
| 安全性       | 无加密，安全性较差 | 有加密机制，安全性较高                  |
| 资源消耗     | 较少               | 由于加密处理，资源消耗更多              |
| 是否需要证书 | 不需要             | 需要                                    |
| 协议         | 运行在TCP协议之上  | 运行在SSL协议之上，SSL运行在TCP协议之上 |

- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议 **安全**，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
- http 协议的 **默认端口** 为 80，https 的默认端口为 443。
- http 的连接很简单，是 **无状态的**。https 握手阶段比较 **费时**，会使页面加载时间延长 50%，增加 10%~20%的耗电。
- https **缓存** 不如 http 高效，会增加数据开销。
- Https 协议需要 ca 证书，费用较高，功能越强大的`证书费`用越高。
- SSL 证书需要绑定  **IP**，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。



## 2.13 对称加密与非对称加密

- 对称加密

    **对称加密指加密和解密使用同一密钥**，**优点是运算速度快，缺点是如何安全将密钥传输给另一方**。常见的对称加密算法有DES、AES等等。

- 非对称加密

    非对称加密指的是加密和解密 **使用不同的密钥**，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。**缺点是运算速度较慢**。常见的非对称加密算法有RSA、DSA、ECC等等。

    非对称加密的工作流程：A生成一对非对称密钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用自己的私钥解密信息。

## 2.14 HTTPS的加密过程

HTTPS是将两者结合起来，使用的对称加密和非对称加密的混合加密算法。**具体做法就是使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。**

简化的工作流程：**服务端生成一对非对称密钥，将公钥发给客户端。客户端生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到客户端发送的对称密钥。**通信双方就可以通过对称密钥进行高效地通信了。

但是仔细想想这其中存在一个很大地问题，就是客户端最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的？

这就需要证书上场了，服务端会向一个权威机构申请一个证书来证明自己的身份，到时候将证书（证书中包含了公钥）发给客户端就可以了，客户端收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。

HTTPS的加密过程：

1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客服端。
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。

上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。

流程图如下：

![HTTPS加密过程](https://segmentfault.com/img/remote/1460000038526733)

## 2.15 常用HTTP状态码

| 状态码 | 类别                                                 |
| ------ | ---------------------------------------------------- |
| 1XX    | 表示消息 信息性状态码                                |
| 2XX    | 成功状态码，代表请求已成功被服务器接收、理解、并接受 |
| 3XX    | 重定向状态码                                         |
| 4XX    | 客户端错误状态码                                     |
| 5XX    | 服务端错误状态码                                     |

常见的HTTP状态码

**1XX 信息性状态码** 代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

- 100 Continue：表示正常，客户端可以继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议，主要用于websocket或http2升级。

**2XX 成功状态码**

- 200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回
- 201 Created：已创建，表示成功请求并创建了新的资源
- 202 Accepted：已接受，已接受请求，但未处理完成。
- 203 非授权信息: 服务器已成功处理请求，但返回的信息可能来自另一来源
- 204 No Content：无内容，服务器成功处理，但未返回内容。
- 205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。
- 206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容

**3XX 重定向状态码** 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

- 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择

- 301 Moved Permanently：永久性重定向 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302 Found：临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303 See Other：和301功能类似，但要求客户端采用get方法获取资源
- 304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
- 305 Use Proxy：所请求的资源必须通过代理访问
- 307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

4XX 客户端错误状态码

- 400 Bad Request：客户端请求的语法错误，服务器无法理解。
- 401 Unauthorized：表示发送的请求需要有认证信息。
- 403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求
- 404 Not Found：服务器无法根据客户端的请求找到资源。
- 405 Method Not Allowed：客户端请求中的方法被禁止
- 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求
- 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时

**5XX 服务端错误状态码** 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

- 500 Internal Server Error：服务器内部错误，无法完成请求
- 501 Not Implemented：服务器不支持请求的功能，无法完成请求
- 502 Bad Gateway: 错误网关 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## 2.16 常见的HTTP方法

| 方法    | 作用                                                    |
| ------- | ------------------------------------------------------- |
| GET     | 获取资源                                                |
| POST    | 传输实体主体                                            |
| PUT     | 上传文件                                                |
| DELETE  | 删除文件                                                |
| HEAD    | 和GET方法类似，但只返回报文首部，不返回报文实体主体部分 |
| PATCH   | 对资源进行部分修改                                      |
| OPTIONS | 查询指定的URL支持的方法                                 |
| CONNECT | 要求用隧道协议连接代理                                  |
| TRACE   | 服务器会将通信路径返回给客户端                          |

为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。

- PUT：上传文件，向服务器添加数据，可以看作增
- DELETE：删除文件
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。
- GET：获取资源，查询服务器资源

## 2.17 GET和POST区别

- 作用

​	GET用于 **获取资源**，POST用于 **传输实体主体**

- 参数位置

​	GET的参数放在URL中，POST的参数存储在实体主体中，并且 **GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。**

- 安全性

​	GET方法因为参数放在URL中，安全性相对于POST较差一些

- 幂等性

​	GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的

**从`w3schools`得到的标准答案的区别如下：**

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中



## 2.18 HTTP 1.0、HTTP 1.1及HTTP 2.0和HTTP3的主要区别

HTTP 1.0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  和HTTP 1.1的区别

- 长连接

    HTTP  1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，**HTTP  1.0 默认使用短连接**，每次请求都要重新建立一次TCP连接，资源消耗较大。请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。

- 缓存处理

    在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。

- 错误状态码

    在HTTP 1.1新增了24个错误状态响应码

- HOST域

    在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。

- 带宽优化及网络连接的使用

    在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。

HTTP 2.0的新特性

- 新的二进制格式：**HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制**，实现方便，健壮性更好。
- **多路复用**：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。
- **header压缩**：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。
- 服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求

**HTTP/2 和 TCP 的缺陷**

HTTP/2 使⽤⼆进制传输、 Header 压缩（HPACK）、多路复⽤等，相较于 HTTP/1.1 ⼤幅提⾼了数据传输效率，但它仍然存在着以下⼏个致命问题（主要由底层⽀撑的 TCP 协议造成）：

- **建⽴连接时间⻓**
- **队头阻塞问题**相较于 HTTP/1.1 更严重  

**HTTP/3 和 QUIC 新特性**

![HTTP2.0和HTTP3能力矩阵对比](https://s2.loli.net/2022/03/20/YHlQ5eVZrsJCUqm.png)

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，⽐如多路复⽤、 0-RTT、使⽤ TLS1.3 加密、流量控制、有序交付、重传等等功能。  

## 2.19 Session、Cookie和Token的主要区别

HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。

- **相同点**
    - **是都存储在客户端**
- **不同点**
    -  **Cookie数据大小不能超过4k，超过最大限制，该cookie会被静默删除**；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
    -  **cookie设置的过期时间之前一直有效**；**localStorage永久存储**，浏览器关闭后数据不丢失除非主动删除数据；**sessionStorage数据在当前浏览器窗口关闭后自动删除**
    -  **cookie的数据会自动的传递到服务器**；**sessionStorage和localStorage数据保存在本地**



- Cookie

    **Cookie是保存在客户端一个小数据块**，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，**当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。**

    **Cookie 的缺陷在于: **

    1. IE6或更低版本最多20个cookie

    2. IE7和之后的版本最多50个cookie

    3. Firefox最多50个cookie

    4. Chrome和Safari没有硬性限制

    5. IE和Opera会清理掉近期最少使用的cookie而Firefox会随机清理掉一些cookie

    6. Cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。

- Session

    **Session是通过Cookie实现的**，和Cookie不同的是，**Session是存在服务端的**。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。

- Token

    客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销

|         | 存放位置     | 占用空间 | 安全性 | 应用场景           |
| ------- | ------------ | -------- | ------ | ------------------ |
| Cookie  | 客户端浏览器 | 小       | 较低   | 一般存放配置信息   |
| Session | 服务端       | 多       | 较高   | 存放较为重要的信息 |

**cookie，localStorage，sessionStorage，indexDB**

|     特性     |                   cookie                   |       localStorage       | sessionStorage |         indexDB          |
| :----------: | :----------------------------------------: | :----------------------: | :------------: | :----------------------: |
| 数据生命周期 |     一般由服务器生成，可以设置过期时间     | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 |                     4K                     |            5M            |       5M       |           无限           |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 |          不参与          |     不参与     |          不参与          |

从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于 `cookie`，我们还需要注意安全性。

|   属性    |                             作用                             |
| :-------: | :----------------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |            不能通过 JS 访问 Cookie，减少 XSS 攻击            |
|  secure   |               只能在协议为 HTTPS 的请求中携带                |
| same-site |    规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击     |

## 2.20 如果客户端禁止 cookie 能实现 session 还能用吗

**可以**，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。

## 2.21 在浏览器中输⼊url地址到显示主页的过程

1. 对输入到浏览器的url进行DNS解析，将域名转换为IP地址。
2. 和目的服务器建立TCP连接
3. 向目的服务器发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析并渲染页面

> 上面为笼统的回答

**从输入URL到页面加载的全过程：**

![从输入URL到页面加载的全过程](https://s2.loli.net/2022/03/16/mJHLgGW54hcMenw.png)

1. 首先在浏览器中输入URL

2. 查找缓存：浏览器先查看**浏览器缓存-系统缓存-路由缓存**中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。

    - 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
    - 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
    - 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
    - ISP缓存：若上述均失败，继续向ISP搜索

3. DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议`

4. 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接

5. 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器

6. 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器

7. 关闭TCP连接：通过四次挥手释放TCP连接

8. 浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：

    - **构建DOM树**：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
    - **构建CSS规则树**：生成CSS规则树（CSS Rule Tree）
    - **构建render树**：Web浏览器将DOM和CSS结合，并构建出渲染树（render tree）
    - **布局（Layout**）：计算出每个节点在屏幕中的位置
    - **绘制（Painting）**：即遍历render树，并使用UI后端层绘制每个节点。

    ![浏览器渲染流程](https://s2.loli.net/2022/03/16/GBIcFL5DJCV9i8Z.png)

9. JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

    - 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。

    - 加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译

    - 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。

    - 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的

          

## 2.22 http 缓存

1. **概念**

    什么是缓存？ 把一些不需要重新获取的内容再重新获取一次

    为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

    哪些资源可以被缓存？ 静态资源，比如 js css img。

2. **强制缓存**

    ![image-20220331201959442](https://s2.loli.net/2022/04/21/jB4YgDSmz9ZC6XK.png)

    Cache-Control：

    - 在 Response Headers 中。
    - 控制强制缓存的逻辑。
    - 例如 Cache-Control: max-age=3153600（单位是秒）

    Cache-Control 有哪些值：

    - max-age：缓存最大过期时间。
    - no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
    - no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

    

3. **协商缓存（对比缓存）**

    - 服务端缓存策略。
    - 服务端判断客户端资源，是否和服务端资源一样。
    - 一致则返回 304，否则返回 200 和最新的资源。

    ![image-20220331202053945](https://s2.loli.net/2022/03/31/SiqysYZD6FCnfGc.png)

4. 