# 从 0 到 1 落地前端工程化

## 1. 开篇 落地前端工程化 告别智商谈兵

### 1.1 **前端工程化** 概念

指使用软件工程的技术与方法对前端开发的技术、工具、流程、经验、方案等指标 **标准化**，它具备**模块化**、**组件化**、**规范化**、**自动化**四大特性，主要目的是 **`降低成本`与`增加效率` **。

![前端工程化](https://s2.loli.net/2022/06/02/1VYQqspwguj4TIM.png)

### 1.2 **之前存在的问题**

- 构建配置、打包配置、公共组件、工具函数等代码片段，每次新开项目都要复制粘贴
- 团队成员的编码风格大相径庭，导致从仓库拉取下来的代码运行起来令控制台一片红
- 团队协作的规范、环境、模块、仓库和文档，太多基建措施导致团队新成员无从入手
- 随着需求迭代引起项目结构与工程文件不断变化，处理不当让项目直接走向重构道路

随着需求迭代的步伐加速，上述问题甚至更多问题无可避免地发生，若一开始未对项目做一些相关工程化措施，项目维度会变得凌乱不堪，甚至达到无法维护的可能，最终只会走向重构道路。

事实上，只要将`前端工程化`的开发思维与解决方案应用到项目中，利用好它的优势，就能轻松实现这些非业务需求，为业务降本增效。

总之，`前端工程化` 不是某个具体的工具，而是**对项目的整体架构与整体规划，使开发者能在未来可判时间内动态规划发展走向，以提升整个项目对用户的服务周期**。学习`前端工程化`不仅能理解清楚一个项目的完整流程，遇到困难也能在复杂的流程中快速定位并解决问题，还能根据自身知识储备制定一些可扩展流程，甚至可预见项目的未来发展方向。

### 1.3 **学习方法**

`前端工程化`可不只是会封装组件库就行。

- 首先要有明确前后端任务分离的能力。简而言之，就是能一眼看出该任务属于前端还是后端，划分好前后端的职责更利于`前端工程化`的接入。这也是基于`前端工程化`解决问题的基础。

- 其次要掌握`前端工程化`的四大核心特性，**模块化**、**组件化**、**规范化**和**自动化**。知道它们如何实现，它们各自标准是什么，因为所有前端工作流程都离不开这些核心内容。

![前端工程化](https://s2.loli.net/2022/06/02/ngBr7ciplUoXZxH.png)

- **规范篇**：熟悉`模块/代码/提交`三大开发阶段规范，通过规范约束自己，保障工作质量与提升开发效率

-  **服务篇**：熟悉`云服务器/域名系统/站服务器`部署服务环境，掌握整体部署与工具配置，学会独立上线应用与服务

- **环境篇**：熟悉`Node/Nvm/Npm`部署开发环境，独立搭建一个`接口服务`，实践`环境/镜像/数据/进程`四种`Node`应用方式

-  **构建篇**：熟悉`构建工具`打包类库模块，独立封装一个`类库模块`，结合`测试用例`保障代码的生产质量

- **组织篇**：熟悉`Monorepo模式`管理多包仓库，独立维护一个`多包仓库`，结合`Npm Scope`发布模块到公共仓库

- **部署篇**：熟悉`自动化工具`部署前端项目，独立打造一个`私有仓库`与`文档站点`，结合`CI/CD`在提交代码时自动部署到公网

- 

### 1.4 背景 前端工程化的兴起

在`2020年`前，整个前端行业对`前端工程化`还是处于一个探索与完善的阶段。在互联网早期发展历史中，`后端开发者`一直挑起工程化的整个大梁，`前端开发者`顶多从事`Web开发`相关工作。相信接触过`ASP/JSP/PHP`工作的`前端开发者`能体验到当时的无奈。

**这种传统模式下的协作效率很低**，即使及时发现一个`Bug`，其解决效率相比现在也是相当低下。有时前端与后端争得面红耳赤，谁也不想背锅。我作为一个从事前端超过七年的过来人，这些情况都不知遇到多少次了，当然这只是每个`前端开发者`曾经的一个缩影，真正让前端兴起是`JS`的蓬勃发展。

曾经的`JS`只是作为丰富网页效果的脚本语言，通过植入预设逻辑就能让网页生动起来，提升用户体验。`JS`自1995年诞生以来，我觉得有六种前端技术让前端在短时间内产生了从量变到质变的跳跃。

- **AJAX**：诞生于`2005年`，无需刷新即可快速动态更新局部页面的Web开发技术
- **Jquery**：诞生于`2006年`，提供简便`JS设计模式`且优化`DOM操作`、`语言增强`、`事件处理`、`动画设计`、`AJAX交互`等功能的JS框架
- **Angular**：诞生于`2009年`，提供`MVC`、`模块化`、`双向绑定`、`依赖注入`、`语义标签`等功能的JS框架
- **Node**：诞生于`2009年`，基于`Chrome V8引擎`使用`事件驱动`与`非阻塞式I/O模型`让JS运行在服务端的JS运行环境
- **React**：诞生于`2013年`，采用声明范式轻松描述应用，通过`虚拟DOM`最大限度减少与`DOM`交互的JS框架
- **Serverless**：诞生于`2015年`，无需服务器管理应用程序的构建与运行的概念

基于上述六种前端技术，我将前端发展历程划分为以下阶段。每种前端技术都为当前阶段提供了推进作用，将前端从一个层次推升到另一个层次。每种前端技术在出现时都可能不受重视，随着时间推移与项目实践，它可能从众多技术中突围而出。这些热门的前端技术都能形成一个庞大且热闹的生态社区，各路开发者都踊跃贡献自身一份力量，这些前端技术慢慢地就会沉淀出一条主流的技术栈或工具链，以推动`前端工程化`的发展。

![前端发展历程](https://s2.loli.net/2022/06/03/QIpMcuwgd3AHPLk.png)

### 1.5 前端工程化的特性

#### 1.5.1 **模块化**

**模块化** 指将一个复杂应用根据预设规范封装为多个块并组合起来，对内实现数据私有化，对外暴露接口与其它模块通信。

模块化是 `前端工程化` 的重中之重。它在 `前端工程化` 中具体表现为：在文件层面上对代码与资源实现拆分与组装，将一个大文件拆分为互相依赖的小文件，再统一拼装与加载。

对于一个完善的 `Web项目`，一般是 `SPA/MPA`，推荐使用以下目录结构将整个项目划分为各种通用模块。为了让目录结构更突出其功能，就不包括那些杂七杂八的工具链配置文件了。

```txt
project
├─ dist          # 输出目录
│  ├─ prod         # 生产环境执行代码
│  └─ test         # 测试环境执行代码
├─ src           # 源码目录
│  ├─ apis         # 接口模块：包括全局接口请求的功能，控制数据定向转换
│  ├─ assets       # 资源模块：包括样式、脚本、字体、图像、音频、视频等资源文件
│  ├─ components   # 组件模块：包括全局通用的基础组件、皮肤主题和字体图标
│  ├─ layouts      # 布局模块：包括以布局为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ flows        # 流程模块：包括以流程为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ pages        # 页面模块：包括以页面为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ routes       # 路由模块：包括全局页面跳转的功能，控制页面自由切换
│  ├─ stores       # 数据模块：包括全局数据状态的功能，控制数据驱动视图
│  ├─ views        # 视图模块：包括以视图为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ utils        # 工具模块：包括全局通用的常量与方法
│  ├─ index.html   # 模板入口文件
│  ├─ index.js     # 脚本入口文件
│  └─ index.scss   # 样式入口文件
└─ package.json
```

对于一个完善的`Node项目`，一般是`接口系统`，推荐使用以下目录结构将整个项目划分为各种通用模块。为了让目录结构更突出其功能，就不包括那些杂七杂八的工具链配置文件了。

```txt
project
├─ dist          # 输出目录
│  ├─ prod         # 生产环境执行代码
│  └─ test         # 测试环境执行代码
├─ src           # 源码目录
│  ├─ assets       # 资源模块：包括样式、脚本、字体、图像、音频、视频等资源文件
│  ├─ models       # 模型模块：包括全局数据模型的功能
│  ├─ routes       # 路由模块：包括全局接口请求的功能
│  ├─ utils        # 工具模块：包括全局通用的常量与方法
│  └─ index.js     # 脚本入口文件
└─ package.json
```

#### 1.5.2 **组件化**

**组件化** 指将一个具备通用功能的交互设计划分为模板、样式和逻辑组成的功能单元，对内管理内部状态满足交互需求，对外提供属性接口扩展用户需求。

组件化是 `前端工程化` 的重要基础。它实现了代码更高层次的复用性，提升开发效率。组件的封装也是对象的封装，同样要做到**高内聚低耦合**，组件化的项目不仅利于单元测试的进行，同样也利于需求迭代的推进。

优秀的组件化遵循以下设计哲学。

- 将设计图划分为最小组件层级
- 使用预设规范创建组件静态版本
- 确定组件内部最小且完整的状态的表示方式
- 确定组件内部最小且完整的状态的放置方式
- 实现数据流的正向传递与反向传递

> **模块化与组件化区别**
>
> * 模块化着重在文件层面上对代码与资源实现拆分与组装
> * 组件化着重在功能层面上对交互与设计实现拆分与组装。

#### 1.5.3 规范化

**规范化** 指将一系列预设规范接入工程各个阶段，通过各项指标标准化开发者的工作流程，引导开发者在团队协作中往更好的方向发展。

规范化是 `前端工程化` 的重要部分。它有效地将一盘松散的规范通过指定标准凝聚在一起，将所有工作流程标准化，协同所有开发者以标准化的方式定义工作流程，同时也影响着代码、文档和日志，甚至影响着每个开发者及其团队发展方向，因此每个成熟的前端团队都有一套身经百战的规范化方案。

规范化更多应用在团队协作中，为每个开发者指明一个方向，引领着成员往该方向走。若团队无规范化，每个开发者各做各的事情，在合并代码时肯定会发生争吵，甚至影响工作效率。

#### 1.5.4 自动化

**自动化** 指将一系列繁琐重复的工作流程交由程序根据预设脚本自动处理，整个工作流程无需人工参与，以解放开发者双手让其更专注业务需求的开发。

自动化是`前端工程化`的智能部分。它既可解放双手又能节省大量时间做更多有意义的事情，常见自动化场景包括但不限于`自动化构建`、`自动化测试`、`自动化打包`、`自动化发布`和`自动化部署`，更高级的自动化场景包括但不限于`持续集成`、`持续交付`和`持续部署`。以自动化构建为例，又可将其划分为以下子任务，这些子任务分布在自动化构建不同阶段，在不同阶段的最佳时刻会调用相关工具处理相关流程

| 任务           | 职责          |
| -------------- | ------------- |
| **Stylelint**  | 校验样式代码  |
| **Eslint**     | 校验脚本代码  |
| **Postcss**    | Postcss → CSS |
| **Sass**       | SASS → CSS    |
| **Less**       | LESS → CSS    |
| **Babel**      | ES6 → ES5     |
| **TypeScript** | TS → JS       |

自动化整体重心偏向于构建，构建为工程服务，工程又为用户服务，因此一个项目会演化出至少两种运行环境，分别是开发环境与生产环境。其中开发环境工程为开发者服务，生产环境工程为用户服务。

- **前后分离**：前端应自成体系且与后端分离，包括但不限于规范、服务、环境、构建、组织和部署方面
- **技术选型**：不能以一个框架满足所有业务场景，需制定多套框架解决方案避免技术瓶颈的出现
- **重构封装**：新生技术不断涌现就要避免改头换面式的重构，重复需求不断出现就要学会举一反三的封装
- **工程设计**：解决方案要合理分层且互相独立，随时应对各种变化，任何一层可低成本被替换与淘汰

![环境与工具](https://s2.loli.net/2022/06/03/1Hk68vTsrDQ7amE.webp)

## 2. 模块规范 在Node环境中运行ESM，可行吗

`前端工程化`完全离不开`Node`，很多需求都基于`Node`完成。一般来说`Node开发`会使用`CJS`编码，但很多`Web开发`的同学已习惯使用`ESM`编码了。

其实无需担心，`Web开发`转向`Node开发`完全可继续使用`ESM`编码。因为`Web`与`Node`都是一种`JS运行环境`，本质上只有`运行环境`不同。

> 当前面临的核心问题是`Node`无法直接使用`ESM`编码。
>
> **部署Node的ESM开发环境**，无需关注`JS运行环境`涉及模块方案的差异性，让`Node开发`也变得像`Web开发`那样丝滑。

### 2.1 模块化背景



`JS` 诞生于 `1995年`，最初设计的目的是实现一些简单的浏览器交互效果，寥寥数语就能为用户提供良好的操作体验。随着 `JS` 的快速发展，各种前端技术得到广泛应用，特别是 `AJAX` 与 `Jquery` 引发的前端大革命让`JS`得到质的提升，但各种问题也接踵而至。

在实际开发过程中，经常会遇到 `变量名称` 或 `函数名称` 一样的情况。这不仅容易造成 **命名冲突**，还会污染全局变量。若在应用特别复杂，存在大量相似代码，又引用很多第三方库的情况下，稍不注意就很易造成文件的 **依赖混乱**。

基于此，`JS` 也引入模块化的概念。**早期的模块化不是真正的模块化，只是通过一些“骚操作”实现看似是模块化的效果**，例如 `立即调用函数表达式` (简称 `IIFE` )就是一个在定义时可立即执行的函数，至于它如何实现模块化，可查看 [MDN文档](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FIIFE)，在此不深入讲述了。**后期的模块化才算是真正的模块化**，它包括 `CJS`、`AMD`、`CMD`、`UMD `和`ESM`，经过多年演变，目前 `Web开发` 倾向于 `ESM`，`Node开发` 倾向于 `CJS`。

模块化让`JS`也能拥有自己的模块化效果，在实际开发中，**一个模块就是一个文件**。模块化的核心包括以下特性，基本都是围绕如何处理文件(`模块`)。

- **拆分**：将代码根据功能拆分为多个可复用模块

- **加载**：通过指定方式加载模块并执行与输出模块

- **注入**：将一个模块的输出注入到另一个模块

- **管理**：因为工程模块数量众多需管理模块间的依赖关系

前端代码爆炸式增长必然会引入`前端工程化 `解决问题，模块化作为 `前端工程化` 中最低成本的应用，很值得每一位开发者遵守。使用模块化开发代码，不仅能提高代码整体可读性，也能增强项目整体维护性。不管是个人开发还是协作开发，模块化都能带来很多好处。

**模块化的作用：**

- **隔离作用域**
- **提供复用性**
- **提高可维护性**
- **解决命名冲突**
- **抽离公共代码**

### 2.2 模块方案

>  **之前引用直接 js 文件的问题**
>
> 以前引用`js文件`都会使用多个`<script>`顺序处理，曾见过一个老旧项目多达`12`个`<script>`，这会导致很多问题，例如以下情况。
>
> - **请求过多**：每个`<script>`都有一个`src`必然会增加`HTTP`请求次数
> - **依赖模糊**：每个`<script>`的摆放顺序都有可能影响前后脚本加载错误
> - **难以维护**：每个`<script>`的变量命名与函数作用域都有可能互相影响

`JS模块化`就很好地解决了上述问题，具体有哪些解决方案？在`JS`发展历程中，主要有六种常见模块方案，分别是**IIFE**、**CJS**、**AMD**、**CMD**、**UMD**和**ESM**。我把它们各自的定义与特性总结在以下脑图中。

![模块方案](https://s2.loli.net/2022/06/03/58XdjU6MliLTPEy.webp)

分析每个模块方案的特性可知，`同步加载`包括`IIFE`与`CJS`，`异步加载`包括`AMD`、`CMD`和`ESM`。浏览器可兼容`IIFE`与`AMD`，服务器可兼容`CJS`，浏览器与服务器都兼容`CMD`、`UMD`和`ESM`。

| -            | **CJS**                                             | **ESM**                                         |
| ------------ | --------------------------------------------------- | ----------------------------------------------- |
| **语法类型** | 动态                                                | 静态                                            |
| **关键声明** | `require`                                           | `export`与`import`                              |
| **加载方式** | 运行时加载                                          | 编译时加载                                      |
| **加载行为** | 同步加载                                            | 异步加载                                        |
| **书写位置** | 任何位置                                            | 顶层位置                                        |
| **指针指向** | `this`指向`当前模块`                                | `this`指向`undefined`                           |
| **执行顺序** | 首次引用时`加载模块` 再次引用时`读取缓存`           | 引用时生成`只读引用` 执行时才是正式取值         |
| **属性引用** | 基本类型属于`复制不共享` 引用类型属于`浅拷贝且共享` | 所有类型属于`动态只读引用`                      |
| **属性修改** | 工作空间可修改引用的值                              | 工作空间不可修改引用的值 但可通过引用的方法修改 |

`Node开发`习惯使用`CJS`编码

- **运行时加载** 指整体加载模块生成一个对象，再从对象上获取所需的属性方法去加载。最大特性是 `全部加载`，只有运行时才能得到该对象，无法在编译时做静态优化。
- **编译时加载** 指直接从模块中获取所需的属性方法去加载。最大特性是 `按需加载`，在编译时就完成模块加载，效率比其他方案高，无法引用模块本身(`本身不是对象`)，但可拓展 `JS` 高级语法( `宏与类型校验` )。

### 2.3 现状

随着主流浏览器逐步支持`ESM`，越来越多目光投注于`Node`对于`ESM`的支持上。目前`Node`使用`CJS`作为官方模块方案，虽然内置模块方案促进`Node`的流行，但也阻碍了`ESM`的引入。

- **原生支持 ESM**

    `2017年10月31日`，`Node`发布了`v8.9.0`，从此只要在命令中增加参数`--experimental-modules`，`Node`就可象征性地支持`ESM`了。

    ```bash
    node --experimental-modules index.js
    ```

    但`低版本 Node`依然无法直接支持`ESM`解析，还需在运行环境中`“做些手脚”`才行。

    接着`Node`发布了`v13.2.0`带来一些新特性，正式取消`--experimental-modules`启动参数。当然并不是删除`--experimental-modules`，而是在其原有基础上实现对`ESM`的实验性支持并默认启动。

    `--experimental-modules`特性包括以下方面。

    - 使用`type`指定模块方案

        - 在`package.json`中指定`type`为`commonjs`，则使用`CJS`

        - 在`package.json`中指定`type`为`module`，则使用`ESM`

    - 使用`--input-type`指定入口文件的模块方案，与`type`一样

        - 命令中增加参数`--input-type=commonjs`，则使用`CJS`
        - 命令中增加参数`--input-type=module`，则使用`ESM`

    - 支持新文件后缀`.cjs`

        - 文件后缀使用`.cjs`，则使用`CJS`

    - 使用`--es-module-specifier-resolution`指定文件名称引用方式

        - 命令中增加参数`--es-module-specifier-resolution=explicit`，则引用模块时必须使用文件后缀(`默认`)
        - 命令中增加参数`--es-module-specifier-resolution=node`，则引用模块时无需使用文件后缀

    - 使用`main`根据`type`指定模块方案加载文件

        - 在`package.json`中指定`main`后会根据`type`指定模块方案加载文件

### 2.4 CJS/ESM 判断方式

`Node`要求使用`ESM`的文件采用`.mjs`后缀，只要文件中存在`import/export命令`就必须使用`.mjs`后缀。若不希望修改文件后缀，可在`package.json`中指定`type`为`module`。基于此，若其他文件使用`CJS`，就需将其文件后缀改为`.cjs`。若在`package.json`中未指定`type`或指定`type`为`commonjs`，则以`.js`为后缀的文件会被解析为`CJS`。

简而言之，`mjs文件`使用`ESM`解析，`cjs文件`使用`CJS`解析，`js文件`使用基于`package.json`指定的`type`解析(`type=commonjs`使用`CJS`，`type=module`使用`ESM`)。

当然还可通过命令参数处理。

`Node v13.2.0`在默认情况下会启动对`ESM`的实验支持，无需在命令中增加`--experimental-modules`参数。那`Node`是如何区分`CJS`与`ESM`？简而言之，`Node`会将以下情况视为`ESM`。

- 文件后缀为`.mjs`

- 文件后缀为`.js`且在`package.json`中指定`type`为`module`

- 命令中增加参数`--input-type=module`

- 命令中增加参数`--eval cmd`

### 2.5 方案：部署Node的ESM开发环境

虽然官方文档有明确的迁移方案，但很多同学还是会存在理解偏差。确实，一连串的操作会让很多未接触或很少接触`Node开发`的同学感觉无比混乱。为了愉快地部署`Node`的`ESM开发环境`，将实现高低两种版本的部署，规范好每种方案的实现方式，再根据自己喜好选择。

将`Node v13.2.0`作为高低版本分界线，当版本`>=13.2.0`则定为高版本，当版本`<13.2.0`则定为低版本。高版本使用`Node原生部署方案`，低版本使用`Node编译部署方案`。

在部署`Node`的`ESM开发环境`前需初始一个示例，以下所有代码都基于该项目进行。

创建 `node-esm` 目录

```bash
mkdir node-esm
cd node-esm
npm init
```

在根目录中创建`package.json`并执行`npm i`安装项目依赖。

```json
{
	"name": "node-esm",
	"version": "1.0.0",
	"main": "src/index.js",
	"scripts": {
		"start": "node src/index.js"
	},
	"dependencies": {
		"@yangzw/bruce-us": "1.0.3"
	}
}
```

创建`src/index.js`文件，加入以下内容。示例引用开源的[@yangzw/bruce-us](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJowayYoung%2Fbruce%2Ftree%2Fmain%2Fpackages%2Fus)，其中`NodeType()`用于获取`Node`相关信息。

```js
import { NodeType } from "@yangzw/bruce-us/dist/node";

console.log(NodeType());
```

#### 2.5.1 Node 原生部署方案

假设`Node`是`v13.2.0`以上版本，执行`npm start`，输出以下信息表示运行失败。

![image-20220603110107552](https://s2.loli.net/2022/06/03/XshY3KIt1WMc4p6.png)

这是因为`Node`根据刚才提到的四种情况也无法识别出是`ESM`，知道原因很快就能找出解决方案了。在保持所有文件后缀为`.js`的前提下，在`package.json`中指定`type`为`module`。

为何一定要保持所有文件后缀为`.js`？作为`前端开发者`且使用`JS`编码，那保证文件后缀为`.js`再正常不过，不想出幺蛾子就不要乱改文件后缀。

为了让`Node`支持`ESM`，还需为其指定`Node/Npm`版本限制。这是为了避免预设与实际情况不同而报错，例如预设该项目在高版本运行，实际却在低版本运行。

`Node`与`Npm`是成双成对地安装，可通过[Node Releases](https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fzh-cn%2Fdownload%2Freleases)查询到`Node v13.2.0`对应`Npm v6.13.1`。

```json
{
	"type": "module",
	"engines": {
		"node": ">=13.2.0",
		"npm": ">=6.13.1"
	}
}
```

重新执行`npm start`，输出以下信息表示运行失败。

```bash
internal/process/esm_loader.js:74
internalBinding("errors").triggerUncaughtException(

Error [ERR_MODULE_NOT_FOUND]: Cannot find module ...
Did you mean to import @yangzw/bruce-us/dist/node.js?
```

根据报错提示，可知道模块路径不存在，这主要是因为**显式文件名称**使用不对。

首先`高版本Node`在默认情况下对`import命令`的文件后缀存在强制性，因此`import "./file"`并不等于`import ./file.js`。其次`CJS`的自动后缀处理行为可通过`--es-module-specifier-resolution=node`开启，但模块主入口并不会受到`ESM`的影响，例如`import Path from "path"`照样可正常运行。在命令中增加`--es-module-specifier-resolution=node`就能解决显示文件名称的问题。

```json
{
	"scripts": {
		"start": "node --es-module-specifier-resolution=node src/index.js"
	}
}
```

为何这样设计显式文件名称？这主要是想通过`Node`提供的通用解决方案鼓励开发者编写`Web`与`Node`共享的代码。

重新修改文件名称后再执行`npm start`，输出以下信息运行成功，这次就无任何问题了！

```bash
{
  nodeVs: '16.14.0',
  npmVs: '8.3.1',
  system: 'windows',
  systemVs: '10.0.19044'
}
```

`Node`使用`ESM`除了上述问题外，还存在一些特别差异。特别是`ESM`不再提供`Node`某些特性与不能灵活引用`json文件`了，因此`__dirname`、`__filename`、`require`、`module`和`exports`这几个特性将无法使用。

不过，上帝关闭一扇门的同时还会打开另一扇窗，可采用以下方式解决这些问题。

- `__filename`与`__dirname`可用`import.meta`对象重建
- `require`、`module`和`exports`可用`import`与`export`代替
- `json文件`的引用可用`Fs模块`的`readFileSync`与`JSON.parse()`代替

```js
import { readFileSync } from "fs";
import { dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
console.log(__filename, __dirname);

const json = readFileSync("./info.json");
const info = JSON.parse(json);
```

`CJS`的循环依赖关系已通过缓存各个模块的`module.exports`对象解决，但`ESM`用了所谓的绑定。简而言之，`ESM`模块不会导出导入值而是引用值。

- **导入引用模块可访问该引用但无法修改它**。
- **导出引用模块可为引用该模块的模块重新分配值且该值由导入引用模块使用**

而`CJS`允许在任何时间点将引用分配给模块的`module.exports`对象，让这些修改仅部分反映在其他模块。

#### 2.5.2 Node 编译部署方案

`Npm`大部分模块都使用`CJS`编码，因为同时使用`require`与`export/import`会报错，所以单个模块无法切换到`ESM`。

可用`babel`将代码从`ESM`转换为`CJS`，因此使用`babel`编译`ESM`代码是低版本`Node`支持`ESM`最稳定的方案无之一。在`Node v8.9.0`前的版本无法使用`--experimental-modules`支持`ESM`，也就更需`babel`解决该问题了。

当然在任何版本中，`babel`都能让新语法转换为与旧环境兼容的代码，因此在`高版本Node`中也同样适用。

接着在`v13.2.0`以下版本中部署。执行以下命令安装`babel`相关工具链到`devDependencies`。

```bash
npm i @babel/cli @babel/core @babel/node @babel/preset-env -D
```

这四个`babel`子包很重要，`Node`能不能支持`ESM`的解析就看它们了。

-  **@babel/cli**：提供支持`@babel/core`的命令运行环境
-  **@babel/core**：提供转译函数
-  **@babel/node**：提供支持`ESM`的命令运行环境
-  **@babel/preset-env**：提供预设语法转换集成环境

安装完毕，在`package.json`中指定`babel`相关配置，将`start`命令中的`node`替换为`babel-node`。

```json
{
	"scripts": {
		"start": "babel-node src/index.js"
	},
	"babel": {
		"presets": [
			"@babel/preset-env"
		]
	}
}
```

**监听脚本自动重启命令**

每次修改脚本都需重启命令才能让脚本内容生效，这太麻烦了，所以我始终喜欢在`Node`中使用`nodemon`。**nodemon**是一个自动检测项目文件发生变化就重启服务的`Npm模块`，是`Node开发`的必备工具。

以**Node编译部署方案**的示例为例。执行`npm i -D nodemon`安装`nodemon`，在`package.json`中指定`nodemonConfig`相关配置，将`start`命令替换为`nodemon -x babel-node src/index.js`。

```json
{
	"nodemonConfig": {
		"env": {
			"NODE_ENV": "dev"
		},
		"execMap": {
			"js": "node --harmony"
		},
		"ext": "js json",
		"ignore": [
			"dist/"
		],
		"watch": [
			"src/"
		]
	}
}
```

修改`src/index.js`内容，`nodemon`就能快速响应修改并重启命令。`nodemon配置`可查看[Nodemon官网](https://link.juejin.cn?target=https%3A%2F%2Fnodemon.io)，在此不深入讲述了。

## 3. 代码规范 每个项目都部署 Lint ?

代码规范是`前端工程化`落地的基石，在其中扮演着监督者的角色，它主要用于约束团队成员的`编码规范`与`编码风格`。应用代码规范有三点好处。

- 强制规范团队编码规范可让新旧成员编码习惯一样
- 增加项目代码的可维护性与可接入性，新成员能快速适应项目的架构与需求
- 保障项目整体质量，可减少无用代码、重复代码、错误代码和漏洞代码的产生几率

这一切的实现都离不开**代码校验工具**中代码格式化的功能。众所周知，基本所有编辑器都会配置**代码校验工具**(以下简称`Lint`)检测代码中的错误或漏洞，根据提供的修复方案格式化出正确代码，让代码更严谨。

